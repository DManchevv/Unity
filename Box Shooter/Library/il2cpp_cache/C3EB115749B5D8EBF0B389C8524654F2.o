N_BATCH_STRIDE + in_image_off;

        // *(p+index) Pointer Mode will use OFfset mode in ASSEMBLY
        //  P[Index] will not use OFfset mode in ASSEMBLY

        const __global _FLOAT* bot1 = bot + glb_in_off;
        for(uint c = 0; c < MLO_N_LCL_IN_MAPS; ++c)
        {
            for(uint i = 0; i < MLO_READ_UNIT; ++i)
            {
                load_buf_bot[c * MLO_READ_UNIT + i] = *(bot1 + i * MLO_FILTER_STRIDE0);
            }
            bot1 += MLO_IN_CHANNEL_STRIDE;
        }

        uint glb_out_off = glb_out_off0 + batch_id * MLO_OUT_BATCH_STRIDE + out_image_off;

        const __global _FLOAT* top1 = top_df + glb_out_off;
        for(uint k = 0; k < MLO_N_LCL_OUT_MAPS; ++k)
        {

            for(uint i = 0; i < MLO_READ_UNIT; ++i)
            {
                load_buf_top[k * MLO_READ_UNIT + i] = *(top1 + i);
            }
            top1 += MLO_OUT_CHANNEL_STRIDE;
        }

        // processing
        // outside loop-i save 1 VGPR than loop-i inside
        for(uint i = 0; i < MLO_READ_UNIT; ++i)
        {
            for(uint k = 0; k < MLO_N_LCL_OUT_MAPS; ++k)
            {
                for(uint c = 0; c < MLO_N_LCL_IN_MAPS; ++c)
                {
                    {
                        accum[k * MLO_N_LCL_IN_MAPS + c] += load_buf_bot[c * MLO_READ_UNIT + i] *
                                                            load_buf_top[k * MLO_READ_UNIT + i];
                    }
                }
            }
        }
    }
#endif

#define LAST_PIXELS (MLO_OUT_CHANNEL_STRIDE % MLO_READ_UNIT)

// PAD/STRIDE never goes to following since MLO_READ_UNIT == 1
#if LAST_PIXELS > 0 && MLO_FILTER_PAD0 == 0 && MLO_FILTER_PAD1 == 0 && MLO_FILTER_STRIDE0 == 1 && \
    MLO_FILTER_STRIDE1 == 1
#define MLO_MAX_LOADS2 (MLO_BATCH_SZ * LAST_PIXELS)
#define MLO_LAST_PIXEL_OFFSET (MLO_OUT_CHANNEL_STRIDE - LAST_PIXELS)

    for(uint faked_off = local_Id0; faked_off < MLO_MAX_LOADS2; faked_off += MLO_GRP_SZ0)
    {

        uint batch_id = faked_off / (LAST_PIXELS); // batch
        uint image_off =
            iMod(faked_off, batch_id, (LAST_PIXELS)) + MLO_LAST_PIXEL_OFFSET; // pixel offset
        uint in_image_off  = image_off * 1;
        uint out_image_off = image_off * 1;

        uint glb_in_off = glb_in_off0 + batch_id * MLO_IN_BATCH_STRIDE + in_image_off;

        // *(p+index) Pointer Mode will use OFfset mode in ASSEMBLY
        //  P[Index] will not use OFfset mode in ASSEMBLY

        const __global _FLOAT* bot1 = bot + glb_in_off;

        for(uint c = 0; c < MLO_N_LCL_IN_MAPS; ++c)
        {
            for(uint i = 0; i < 1; ++i)
            {
                load_buf_bot[c * MLO_READ_UNIT + i] = *(bot1 + i);
            }
            bot1 += MLO_IN_CHANNEL_STRIDE;
        }

        uint glb_out_off = glb_out_off0 + batch_id * MLO_OUT_BATCH_STRIDE + out_image_off;

        const __global _FLOAT* top1 = top_df + glb_out_off;
        for(uint k = 0; k < MLO_N_LCL_OUT_MAPS; ++k)
        {
            for(uint i = 0; i < 1; ++i)
            {
                load_buf_top[k * MLO_READ_UNIT + i] = *(top1 + i);
            }
            top1 += MLO_OUT_CHANNEL_STRIDE;
        }

        // processing
        // outside loop-i save 1 VGPR than loop-i inside
        for(uint i = 0; i < 1; ++i)
        {
            for(uint k = 0; k < MLO_N_LCL_OUT_MAPS; ++k)
            {
                for(uint c = 0; c < MLO_N_LCL_IN_MAPS; ++c)
                {
                    {
                        accum[k * MLO_N_LCL_IN_MAPS + c] += load_buf_bot[c * MLO_READ_UNIT + i] *
                                                            load_buf_top[k * MLO_READ_UNIT + i];
                    }
                }
            }
        }
    }
#endif

    __private _FLOAT accum_to_store = (_FLOAT)(0);

    for(uint K = 0; K < MLO_N_LCL_OUT_MAPS; K++)
    {
        barrier(CLK_LOCAL_MEM_FENCE);

        for(uint C = 0; C < MLO_N_LCL_IN_MAPS; C++)
        {
            sdata[local_Id0 + MLO_GRP_SZ0 * C] = accum[K * MLO_N_LCL_IN_MAPS + C];
        }

        barrier(CLK_LOCAL_MEM_FENCE);

        // Reduction every MLO_GRP_SZ0* MLO_GRP_SZ1 to trhead 0
        for(uint s = ((MLO_GRP_SZ0) >> 2); s > 0; s = (s >> 2))
        {
            if(local_Id0 < s)
            {
                for(uint C = 0; C < MLO_N_LCL_IN_MAPS; C++)
                {
                    sdata[local_Id0 + MLO_GRP_SZ0 * C] +=
                        sdata[MLO_GRP_SZ0 * C + local_Id0 + s] +
                        sdata[MLO_GRP_SZ0 * C + local_Id0 + 2 * s] +
                        sdata[MLO_GRP_SZ0 * C + local_Id0 + 3 * s];
                }
            }
            // NO need inside 1 wave: barrier(CLK_LOCAL_MEM_FENCE);
        }

        barrier(CLK_LOCAL_MEM_FENCE);

        // MLO_N_LCL_IN_MAPS store
        if((local_Id0 & ~0x7) == (K * MLO_N_LCL_IN_MAPS))
        {
            accum_to_store = sdata[0 + (local_Id0 & 0x7) * MLO_GRP_SZ0];
        }

        // only 1st wave need to barrier: it will remove all scratch registers
    }

    if(local_Id0 < (MLO_ACCUM_SZ))
    {

        // Store to Memory
        __global _FLOAT* __restrict weights_ptr =
            weights_df + (K_OFFSET + (local_Id0 / MLO_N_LCL_IN_MAPS)) * MLO_WEI_CHANNEL_STRIDE +
            C_OFFSET + (local_Id0 % MLO_N_LCL_IN_MAPS);

        {
            __global _FLOAT* weights_ptr2 = weights_ptr;
            *weights_ptr2                 = accum_to_store;
        }
    }
}

__attribute__((reqd_work_group_size(MLO_GRP_SZ0, MLO_GRP_SZ1, MLO_GRP_SZ2))) __kernel void
MIOpenCvBwdWrW_16x16map(const __global _FLOAT* __restrict top_df,
                        const __global _FLOAT* __restrict bot,
                        __global _FLOAT* __restrict weights_df,
                        UNUSED _FLOAT padding_val)
{
    __local _FLOAT sdata[MLO_GRP_SZ0 * 8];
    // 64 threds split into 4 grpoups: every 16 threads accumulate 8x8
    //
    // 256 threads split inot 4 groups : every 64 threads accumulate 8x8
    //

    // Global_group_Id0:  [TILE_BLOCK]
    // Global_Id0:  [C/16] * 64 or 256
    // Global_group_Id1:  [K/16]
    // Global_group_Id2:  [C/16/ (MLO_N_IN_TILE_BLOCK= 8 or 4) ]

    // uint group_id0 = get_group_id(0);
    // uint group_id1 = get_group_id(1);

    uint local_Id0 = get_local_id(0);

// traverse small batch size to have better performance
#if MLO_IN_BATCH_STRIDE < MLO_OUT_BATCH_STRIDE
    uint C_OFFSET = get_group_id(0) * MLO_N_LCL_IN_MAPS;
    uint K_OFFSET = get_group_id(1) * MLO_N_LCL_OUT_MAPS;

#else
    uint K_OFFSET = get_group_id(0) * MLO_N_LCL_OUT_MAPS;
    uint C_OFFSET = get_group_id(1) * MLO_N_LCL_IN_MAPS;

#endif

    // Split into 4 groups for C[0,1,0,1], K [0,0,1,1]
    uint k_offset2 = ((local_Id0 / (MLO_GRP_SZ0 / 4)) / 2) * MLO_N_LCL_OUT_MAPS_ONCE;
    uint c_offset2 = ((local_Id0 / (MLO_GRP_SZ0 / 4)) % 2) * MLO_N_LCL_IN_MAPS_ONCE;

    uint glb_out_off0 = (K_OFFSET + k_offset2) * MLO_OUT_CHANNEL_STRIDE;
    uint glb_in_off0  = (C_OFFSET + c_offset2) * MLO_IN_CHANNEL_STRIDE;

    // NO preload
    __private _FLOAT load_buf_top[MLO_N_LCL_OUT_MAPS_ONCE * MLO_READ_UNIT];
    __private _FLOAT load_buf_bot[MLO_N_LCL_IN_MAPS_ONCE * MLO_READ_UNIT];

    __private _FLOAT accum[MLO_ACCUM_SZ];

    // CNHW will be continous address to utlize X4 load;
    // NCHW will be hard mode till now

    for(uint i = 0; i < MLO_ACCUM_SZ; i++)
    {
        accum[i] = (_FLOAT)(0);
    }

    for(uint i = 0; i < MLO_N_LCL_OUT_MAPS_ONCE; i++)
    {
        sdata[local_Id0 + i * MLO_GRP_SZ0] = (_FLOAT)(0);
    }

#if MLO_OUT_CHANNEL_READ_SZ > 0
    for(uint faked_off = (local_Id0 % (MLO_GRP_SZ0 / 4)); faked_off < MLO_MAX_LOADS;
        faked_off += (MLO_GRP_SZ0 / 4))
    {
#if MLO_FILTER_PAD0 > 0 || MLO_FILTER_PAD1 > 0 || \
    (!MLO_TWO_PASSES && (MLO_FILTER_STRIDE0 > 1 || MLO_FILTER_STRIDE1 > 1))

#if 1 // MLO_READ_UNIT == 1
        uint batch_id = faked_off / ((MLO_OUT_PAD_WIDTH / MLO_READ_UNIT) * MLO_OUT_PAD_HEIGHT);
        uint faked_off2 =
            iMod(faked_off, batch_id, ((MLO_OUT_PAD_WIDTH / MLO_READ_UNIT) * MLO_OUT_PAD_HEIGHT));

        uint out_y_off = iDiv_legacy(faked_off2, (MLO_OUT_PAD_WIDTH / MLO_READ_UNIT));
        uint out_x_off =
            iMod(faked_off2, out_y_off, (MLO_OUT_PAD_WIDTH / MLO_READ_UNIT)) * MLO_READ_UNIT;

        uint out_image_off =
            (out_y_off + MLO_OUT_PAD_MIN_Y) * MLO_OUT_WIDTH + (out_x_off + MLO_OUT_PAD_MIN_X);

        uint in_x_off = out_x_off * MLO_FILTER_STRIDE0 + MLO_IN_PAD_MIN_X;
        uint in_y_off = out_y_off * MLO_FILTER_STRIDE1 + MLO_IN_PAD_MIN_Y;

        uint in_image_off = in_y_off * MLO_IN_STRIDE + in_x_off;
#endif
#if 0 // PER_ROW which will be enabled after SGPR offset is enabled.
        uint batch_id   = iDiv_legacy( faked_off,  (MLO_OUT_PAD_WIDTH ));
        uint faked_off2 = iMod( faked_off,  batch_id, (MLO_OUT_PAD_WIDTH ));

        uint out_x_off = 0;
        uint out_y_off = faked_off2;

        uint out_image_off = (out_y_off + MLO_OUT_PAD_MIN_Y) * MLO_OUT_WIDTH + (out_x_off +MLO_OUT_PAD_MIN_X);

        uint in_x_off = out_x_off * MLO_FILTER_STRIDE0 + MLO_IN_PAD_MIN_X;
        uint in_y_off = out_y_off * MLO_FILTER_STRIDE1 + MLO_IN_PAD_MIN_Y;

        uint in_image_off  = in_y_off * MLO_IN_WIDTH + in_x_off;

        //uint glb_in_off  = glb_in_off0  + batch_id * MLO_IN_BATCH_STRIDE   + in_image_off ;
        //uint glb_out_off = glb_out_off0 + batch_id * MLO_OUT_BATCH_STRIDE  + out_image_off;

#endif

#else

        uint batch_id      = faked_off / (MLO_OUT_CHANNEL_READ_SZ);                // batch
        uint image_off     = iMod(faked_off, batch_id, (MLO_OUT_CHANNEL_READ_SZ)); // pixel offset
        uint in_image_off  = image_off * MLO_READ_UNIT;
        uint out_image_off = image_off * MLO_READ_UNIT;
#endif
        uint glb_in_off = glb_in_off0 + batch_id * MLO_IN_BATCH_STRIDE + in_image_off;

        // *(p+index) Pointer Mode will use OFfset mode in ASSEMBLY
        //  P[Index] will not use OFfset mode in ASSEMBLY

        const __global _FLOAT* bot1 = bot + glb_in_off;

        for(uint c = 0; c < MLO_N_LCL_IN_MAPS_ONCE; ++c)
        {
            for(uint i = 0; i < MLO_READ_UNIT; ++i)
            {
                load_buf_bot[c * MLO_READ_UNIT + i] = *(bot1 + i * MLO_FILTER_STRIDE0);
            }
            bot1 += MLO_IN_CHANNEL_STRIDE;
        }

        uint glb_out_off = glb_out_off0 + batch_id * MLO_OUT_BATCH_STRIDE + out_image_off;

        const __global _FLOAT* top1 = top_df + glb_out_off;

        for(uint k = 0; k < MLO_N_LCL_OUT_MAPS_ONCE; ++k)
        {
            for(uint i = 0; i < MLO_READ_UNIT; ++i)
            {
                load_buf_top[k * MLO_READ_UNIT + i] = *(top1 + i);
            }
            top1 += MLO_OUT_CHANNEL_STRIDE;
        }

        // processing
        // outside loop-i save 1 VGPR than loop-i inside
        for(uint i = 0; i < MLO_READ_UNIT; ++i)
        {
            for(uint k = 0; k < MLO_N_LCL_OUT_MAPS_ONCE; ++k)
            {
                for(uint c = 0; c < MLO_N_LCL_IN_MAPS_ONCE; ++c)
                {
                    // for(uint i = 0; i < MLO_READ_UNIT; ++i)
                    {
                        accum[k * MLO_N_LCL_IN_MAPS_ONCE + c] +=
                            load_buf_bot[c * MLO_READ_UNIT + i] *
                            load_buf_top[k * MLO_READ_UNIT + i];
                    }
                }
            }
        }
    }
#endif

#undef LAST_PIXELS
#undef MLO_MAX_LOADS2
#undef MLO_LAST_PIXEL_OFFSET

#define LAST_PIXELS (MLO_OUT_CHANNEL_STRIDE % MLO_READ_UNIT)

// PAD/STRIDE never goes to LAST_PIXELS
#if LAST_PIXELS > 0 && MLO_FILTER_PAD0 == 0 && MLO_FILTER_PAD1 == 0 && MLO_FILTER_STRIDE0 == 1 && \
    MLO_FILTER_STRIDE1 == 1
#define MLO_MAX_LOADS2 (MLO_BATCH_SZ * LAST_PIXELS)
#define MLO_LAST_PIXEL_OFFSET (MLO_OUT_CHANNEL_STRIDE - LAST_PIXELS)

    for(uint faked_off = (local_Id0 % (MLO_GRP_SZ0 / 4)); faked_off < MLO_MAX_LOADS2;
        faked_off += (MLO_GRP_SZ0 / 4))
    {
        uint batch_id  = (faked_off / (LAST_PIXELS));              // batch
        uint image_off = iMod(faked_off, batch_id, (LAST_PIXELS)); // pixel offset
        image_off += MLO_LAST_PIXEL_OFFSET;

        uint glb_in_off = glb_in_off0 + batch_id * MLO_IN_BATCH_STRIDE + image_off * 1;

        // *(p+index) Pointer Mode will use OFfset mode in ASSEMBLY
        //  P[Index] will not use OFfset mode in ASSEMBLY

        const __global _FLOAT* bot1 = bot + glb_in_off;
        for(uint c = 0; c < MLO_N_LCL_IN_MAPS_ONCE; ++c)
        {
            for(uint i = 0; i < 1; ++i)
            {
                load_buf_bot[c * MLO_READ_UNIT + i] = *(bot1 + i);
            }
            bot1 += MLO_IN_CHANNEL_STRIDE;
        }

        uint glb_out_off = glb_out_off0 + batch_id * MLO_OUT_BATCH_STRIDE + image_off * 1;

        const __global _FLOAT* top1 = top_df + glb_out_off;

        for(uint k = 0; k < MLO_N_LCL_OUT_MAPS_ONCE; ++k)
        {
            for(uint i = 0; i < 1; ++i)
            {
                load_buf_top[k * MLO_READ_UNIT + i] = *(top1 + i);
            }
            top1 += MLO_OUT_CHANNEL_STRIDE;
        }

        // processing
        // outside loop-i save 1 VGPR than loop-i inside
        for(uint i = 0; i < 1; ++i)
        {
            for(uint k = 0; k < MLO_N_LCL_OUT_MAPS_ONCE; ++k)
            {
                for(uint c = 0; c < MLO_N_LCL_IN_MAPS_ONCE; ++c)
                {
                    {
                        accum[k * MLO_N_LCL_IN_MAPS_ONCE + c] +=
                            load_buf_bot[c * MLO_READ_UNIT + i] *
                            load_buf_top[k * MLO_READ_UNIT + i];
                    }
                }
            }
        }
    }
#endif

    __private _FLOAT accum_to_store[4];
    accum_to_store[0] = (_FLOAT)(0);
    accum_to_store[1] = (_FLOAT)(0);
    accum_to_store[2] = (_FLOAT)(0);
    accum_to_store[3] = (_FLOAT)(0);

    // 1 loop reduction 8xC per thread, 32 result per workgroup

    for(uint K = 0; K < MLO_N_LCL_OUT_MAPS_ONCE; K++)
    {
        barrier(CLK_LOCAL_MEM_FENCE);

        for(uint C = 0; C < MLO_N_LCL_IN_MAPS_ONCE; C++)
        {
            sdata[local_Id0 + MLO_GRP_SZ0 * C] = accum[K * MLO_N_LCL_IN_MAPS_ONCE + C];
        }
        barrier(CLK_LOCAL_MEM_FENCE);

        // Reduction every MLO_GRP_SZ0* MLO_GRP_SZ1 to trhead 0 inside 1 wave
        for(uint s = (MLO_GRP_SZ0 >> 2); s >= 4; s = (s >> 2))
        {
            // Every time reduce to 1/4
            // Final: offset 0, 1, 2, 3 has the accumualte value
            if(local_Id0 < s)
            {
                for(uint C = 0; C < MLO_N_LCL_IN_MAPS_ONCE; C++)
                {
                    // reduce to final 4x
                    sdata[local_Id0 + MLO_GRP_SZ0 * C] =
                        sdata[local_Id0 * 4 + 0 + MLO_GRP_SZ0 * C] +
                        sdata[local_Id0 * 4 + 1 + MLO_GRP_SZ0 * C] +
                        sdata[local_Id0 * 4 + 2 + MLO_GRP_SZ0 * C] +
                        sdata[local_Id0 * 4 + 3 + MLO_GRP_SZ0 * C];
                }
            }
            // NO need inside 1 wave: barrier(CLK_LOCAL_MEM_FENCE);
        }

        barrier(CLK_LOCAL_MEM_FENCE);

        // MLO_N_LCL_IN_MAPS store 32 DWORD once
        if((local_Id0 & ~0x7) == (K * (MLO_N_LCL_IN_MAPS_ONCE)))
        {
            accum_to_store[0] = sdata[0 + (local_Id0 & 0x7) * MLO_GRP_SZ0];
            accum_to_store[1] = sdata[1 + (local_Id0 & 0x7) * MLO_GRP_SZ0];
            accum_to_store[2] = sdata[2 + (local_Id0 & 0x7) * MLO_GRP_SZ0];
            accum_to_store[3] = sdata[3 + (local_Id0 & 0x7) * MLO_GRP_SZ0];
        }

        // only 1st wave need to barrier: it will remove all scratch registers
    }

    if(local_Id0 < (MLO_ACCUM_SZ))
    {

        // Store to Memory
        __global _FLOAT* __restrict weights_ptr =
            weights_df +
            (K_OFFSET + (local_Id0 / MLO_N_LCL_IN_MAPS_ONCE)) * MLO_WEI_CHANNEL_STRIDE + C_OFFSET +
            (local_Id0 % MLO_N_LCL_IN_MAPS_ONCE);

        {
            __global _FLOAT* weights_ptr1 = weights_ptr;
            for(uint k = 0; k < 2; k++)
                for(uint c = 0; c < 2; c++)
                {
                    __global _FLOAT* weights_ptr2 =
                        weights_ptr1 + k * MLO_N_LCL_IN_MAPS_ONCE * MLO_WEI_CHANNEL_STRIDE +
                        c * MLO_N_LCL_IN_MAPS_ONCE;
                    *weights_ptr2 = accum_to_store[k * 2 + c];
                }
        }
    }
}
  /*******************************************************************************
 *
 * MIT License
 *
 * Copyright (c) 2017 Advanced Micro Devices, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 *******************************************************************************/
/*******************************************************************************
 *
 * MIT License
 *
 * Copyright (c) 2019 Advanced Micro Devices, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 *******************************************************************************/
/*******************************************************************************
 *
 * MIT License
 *
 * Copyright (c) 2019 Advanced Micro Devices, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 *******************************************************************************/
typedef union
{
    uint u32;
    ushort2 ushortx2;
    float f32;
} cvt_bf16_fp32_t;

float bfloat16_to_float(ushort src_val)
{
    cvt_bf16_fp32_t target_val;
    target_val.ushortx2 = (ushort2)(0, src_val);
    return target_val.f32;
}

ushort float_to_bfloat16(float src_val)
{
    cvt_bf16_fp32_t target_val;
    target_val.f32 = src_val;
    // BF16 round and NaN preservation code matches
    // https://github.com/ROCmSoftwarePlatform/rocBLAS/blob/develop/library/include/rocblas_bfloat16.h
    if((~target_val.u32 & 0x7f800000) == 0) // Inf or NaN
    {
        // When all of the exponent bits are 1, the value is Inf or NaN.
        // Inf is indicated by a zero mantissa. NaN is indicated by any nonzero
        // mantissa bit. Quiet NaN is indicated by the most significant mantissa
        // bit being 1. Signaling NaN is indicated by the most significant
        // mantissa bit being 0 but some other bit(s) being 1. If any of the
        // lower 16 bits of the mantissa are 1, we set the least significant bit
        // of the bfloat16 mantissa, in order to preserve signaling NaN in case
        // the bloat16's mantissa bits are all 0.
        if((target_val.u32 & 0xffff) != 0)
        {
            target_val.u32 |= 0x10000; // Preserve signaling NaN
        }
    }
    else
    {
#ifdef MIOPEN_USE_RNE_BFLOAT16
        // When the exponent bits are not all 1s, then the value is zero, normal,
        // or subnormal. We round the bfloat16 mantissa up by adding 0x7FFF, plus
        // 1 if the least significant bit of the bfloat16 mantissa is 1 (odd).
        // This causes the bfloat16's mantissa to be incremented by 1 if the 16
        // least significant bits of the float mantissa are greater than 0x8000,
        // or if they are equal to 0x8000 and the least significant bit of the
        // bfloat16 mantissa is 1 (odd). This causes it to be rounded to even when
        // the lower 16 bits are exactly 0x8000. If the bfloat16 mantissa already
        // has the value 0x7f, then incrementing it causes it to become 0x00 and
        // the exponent is incremented by one, which is the next higher FP value
        // to the unrounded bfloat16 value. When the bfloat16 value is subnormal
        // with an exponent of 0x00 and a mantissa of 0x7F, it may be rounded up
        // to a normal value with an exponent of 0x01 and a mantissa of 0x00.
        // When the bfloat16 value has an exponent of 0xFE and a mantissa of 0x7F,
        // incrementing it causes it to become an exponent of 0xFF and a mantissa
        // of 0x00, which is Inf, the next higher value to the unrounded value.
        target_val.u32 +=
            (0x7fff + (target_val.ushortx2.hi & 1)); // Round to nearest, round to even
#else                                                // Truncation rounding
// do nothing
#endif
    }
    return target_val.ushortx2.hi;
}


#define PPCAT_NX(A, B) A##B
#define PPCAT(A, B) PPCAT_NX(A, B)
#define TWO 2
#define FOUR 4
#define EIGHT 8

#if MIOPEN_USE_FP16 == 1
#pragma OPENCL EXTENSION cl_khr_fp16 : enable
#define _FLOAT half
#define _FLOAT_ACCUM float
#define SIZEOF_FLOAT 2 /* sizeof is unavailable for preprocessor */
#ifndef HALF_MAX
#define MAX_VAL 65504 /* max value */
#else
#define MAX_VAL HALF_MAX
#endif
#endif
#if MIOPEN_USE_FP32 == 1
#define _FLOAT float
#define _FLOAT_ACCUM float
#define SIZEOF_FLOAT 4 /* sizeof is unavailable for preprocessor */
#ifndef FLT_MAX
#define MAX_VAL 3.402823466e+38F /* max value */
#else
#define MAX_VAL FLT_MAX
#endif
#endif
#if MIOPEN_USE_BFP16 == 1
#define _FLOAT ushort
#define _FLOAT_ACCUM float
#define SIZEOF_FLOAT 2 /* sizeof is unavailable for preprocessor */
#define MAX_VAL 0x7F7F /* max value */
#endif

#define _FLOAT2 PPCAT(_FLOAT, TWO)
#define _FLOAT4 PPCAT(_FLOAT, FOUR)
#define _FLOAT8 PPCAT(_FLOAT, EIGHT)

#if MIOPEN_USE_FP16 == 1
#define CVT_FLOAT2ACCUM(x) ((_FLOAT_ACCUM)(x))
#define CVT_ACCUM2FLOAT(x) ((_FLOAT)(x))
#endif
#if MIOPEN_USE_FP32 == 1
#define CVT_FLOAT2ACCUM(x) ((_FLOAT_ACCUM)(x))
#define CVT_ACCUM2FLOAT(x) ((_FLOAT)(x))
#endif
#if MIOPEN_USE_BFP16 == 1
#define CVT_FLOAT2ACCUM(x) bfloat16_to_float(x)
#define CVT_ACCUM2FLOAT(x) float_to_bfloat16(x)
#endif


#define UNUSED __attribute__((__unused__))

#define DBG_OUT_OF_RNGE 0
#define DBG_PRINTF 0

// filter size for all filters with small n of input maps (first layer)
// split a long filter by stride

#ifndef MLO_N_FILTER_SPLITS1
#define MLO_N_FILTER_SPLITS1 ((MLO_FILTER_SIZE1 + MLO_FILTER_STRIDE1 - 1) / MLO_FILTER_STRIDE1)
#endif
#ifndef MLO_N_FILTER_SPLITS0
#define MLO_N_FILTER_SPLITS0 ((MLO_FILTER_SIZE0 + MLO_FILTER_STRIDE0 - 1) / MLO_FILTER_STRIDE0)
#endif
#ifndef MLO_OUT_PIX_TILE0
#define MLO_OUT_PIX_TILE0 MLO_N_FILTER_SPLITS0
#endif
// processing arrangement
// generate full output width
// extent1 == MLO_GRP_SZ / MLO_PROCESING_WIDTH
#ifndef MLO_OUT_EXTENT1
#define MLO_PROCESSING_WIDTH ((MLO_OUT_WIDTH + MLO_OUT_PIX_TILE0 - 1) / MLO_OUT_PIX_TILE0)
#define MLO_OUT_EXTENT1 (MLO_GRP_SZ / MLO_PROCESSING_WIDTH)
#endif

#define MLO_WEI_LCL_WIDTH MLO_FILTER_SIZE0 //(MLO_N_FILTER_SPLITS0*MLO_FILTER_STRIDE0)
#define MLO_WEI_EXTENT1 MLO_N_FILTER_SPLITS1
#define MLO_WEI_SZ (MLO_WEI_EXTENT1 * MLO_WEI_LCL_WIDTH)
// LDS size
#ifndef MLO_WEI_LCL_SZ
#define MLO_WEI_LCL_SZ (MLO_WEI_SZ * MLO_N_LCL_OUT_MAPS * MLO_N_LCL_IN_MAPS)
#endif

#ifndef MLO_IN_LCL_HEIGHT
#define MLO_IN_LCL_HEIGHT (MLO_OUT_EXTENT1 + MLO_N_FILTER_SPLITS1 - 1)
#endif
// there is an assumption that the scanline fits into LDS
#define MLO_N_IN_HORIZ_PIX_READS (MLO_IN_WIDTH)
#ifndef MLO_N_IN_HORIZ_READS
#define MLO_N_IN_HORIZ_READS ((MLO_N_IN_HORIZ_PIX_READS + MLO_READ_UNIT - 1) / MLO_READ_UNIT)
#endif

#define MLO_IN_N_PIXS_OFF \
    (MLO_N_IN_HORIZ_PIX_READS - (MLO_N_IN_HORIZ_PIX_READS / MLO_READ_UNIT) * MLO_READ_UNIT)

#define MLO_IN_LCL_WIDTH (MLO_N_IN_HORIZ_READS * MLO_READ_UNIT + 2 * MLO_FILTER_PAD0)
#define MLO_IN_LCL_SZ (MLO_IN_LCL_WIDTH * MLO_IN_LCL_HEIGHT)
// LDS size
#define MLO_TOTAL_IN_LCL_SZ (MLO_N_LCL_BATCHS * MLO_IN_LCL_SZ * MLO_N_LCL_IN_MAPS)

#ifndef MLO_LCL_MEM_SZ
#define MLO_LCL_MEM_SZ (MLO_WEI_LCL_SZ + MLO_TOTAL_IN_LCL_SZ)
#endif

// number of loops to flush put full output map
#define MLO_N_OUT_BLKS 1 //((MLO_OUT_HEIGHT + (MLO_OUT_PIX_TILE1*MLO_N_OUT_FOLDS1) -1) /
                         //(MLO_OUT_PIX_TILE1*MLO_N_OUT_FOLDS1))

#define MLO_HW_WAVE_ID_SETTING 1

#if defined(__AMDGCN__)
extern uint __llvm_amdgcn_readfirstlane(uint) __asm("llvm.amdgcn.readfirstlane");
#define uniform(x) __llvm_amdgcn_readfirstlane(x)
#else
#define uniform(x) (x)
#endif

uint getWaveId()
{
    uint wave_id = 0;

#if MLO_HW_WAVE_ID_SETTING && defined(__AMDGCN__)
    // (local_id/wavesize) has the same value in all workitems.
    // Make it scalar to enable scalarization optimizations.
    extern uint __llvm_amdgcn_readfirstlane(uint) __asm("llvm.amdgcn.readfirstlane");

    wave_id = __llvm_amdgcn_readfirstlane((uint)(get_local_id(0) >> MLO_LG2_WAVE_SZ));
// Alternate implementation:
//__asm__ ("v_readfirstlane_b32 %0, %1" : "=s" (wave_id) : "v" ((uint)(get_local_id(0) >>
// MLO_LG2_WAVE_SZ)) );

#elif MLO_HW_WAVE_ID_SETTING
    // FIXME Conduct enabling from the host code.
    extern __attribute__((const)) uint __hsail_get_dynwave_id(void);
    wave_id = __hsail_get_dynwave_id();
    wave_id &= MLO_N_WAVES_MASK;

#else
    wave_id = (get_local_id(0) >> MLO_LG2_WAVE_SZ);
#endif
    return (wave_id);
}

uint getWaveLocalId()
{
    uint lcl_wave_id = get_local_id(0) & ((1 << MLO_LG2_WAVE_SZ) - 1);
    return (lcl_wave_id);
}

uint getLocalId(uint wave_id, uint wave_lcl_id)
{
    uint lcl_id = (wave_id << MLO_LG2_WAVE_SZ) + wave_lcl_id;
    return (lcl_id);
}

/*******************************************************************************
 *
 * MIT License
 *
 * Copyright (c) 2019 Advanced Micro Devices, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 *******************************************************************************/
uint iDiv_legacy(uint v, uint d)
{
    uint r = (uint)((float)v * (1.0f / (float)d) + 0.00001f);
    return (r);
}

uint iDiv(uint v, uint d)
{
    uint r = v / d;
    return (r);
}

uint iMod(uint v, uint u, uint d)
{
    uint r = v - mul24((uint)u, (uint)d);
    return (r);
}


void ReduceKernel(__local _FLOAT* lcl_blob,
                  _FLOAT* weights_accum,
                  uint lcl_id,
                  uint scan_lcl,
                  uint sum_stride,
                  uint unit_len,
                  UNUSED bool debug)
{
    for(uint j = (sum_stride >> 1); j > scan_lcl; j >>= 1)
    {
        barrier(CLK_LOCAL_MEM_FENCE);
        for(uint i = 0; i < unit_len; ++i)
        {

            weights_accum[i] += lcl_blob[(lcl_id + j) * unit_len + i];

            lcl_blob[lcl_id * unit_len + i] = weights_accum[i];
        }
    }
}

#if MLO_DIR_FORWARD == 1

// TO DO: remove f_s and c from offest calculation
void fetchWeights(uint c,
                  uint k_idx,
                  uint f_s,
                  uint lcl_id,
                  uint wei_read,
                  uint gbl_wei_off,
                  __local _FLOAT* wei_mem,
                  const __global _FLOAT* weights)
{
    // read weights by stride
    for(uint w = lcl_id; w < (wei_read / MLO_FILTER_SIZE0) * MLO_N_LCL_OUT_MAPS; w += MLO_GRP_SZ)
    {
        uint k = iDiv_legacy(w, (wei_read / MLO_FILTER_SIZE0));
        uint j = iMod(w, k, (wei_read / MLO_FILTER_SIZE0));
        int wei_off =
            ((j * MLO_FILTER_STRIDE1 + f_s) < MLO_FILTER_SIZE1 && k_idx + k < MLO_N_OUTPUTS)
                ? gbl_wei_off + k * MLO_WEI_BATCH_STRIDE + c * MLO_WEI_CHANNEL_STRIDE +
                      (j * MLO_FILTER_STRIDE1 + f_s) * MLO_FILTER_SIZE0
                : 0;
        const __global _FLOAT* wei_p = &weights[wei_off];

        for(uint i = 0; i < MLO_FILTER_SIZE0; ++i)
        {
            _FLOAT weight                                       = wei_p[i];
            wei_mem[k * MLO_WEI_SZ + j * MLO_WEI_LCL_WIDTH + i] = weight;
#if DBG_OUT_OF_RNGE == 1
            if(wei_off + i >= MLO_N_OUTPUTS * MLO_N_INPUTS * MLO_FILTER_SIZE1 * MLO_FILTER_SIZE0)
            {
                printf("K:err:weights out-of-range");
            }
#endif
        }
#if 0
		if (ob == 0 && k == 1)
		{
			printf("G:w: %d %d %d %d %f %f\n",
				//										lcl_id,
				//										w,
				//										f_s,
				//										j,
				//										i,
				//										k_idx,
				k*MLO_WEI_SZ + j*MLO_WEI_LCL_WIDTH + i,
				gbl_wei_off,
				wei_off + (j*MLO_FILTER_STRIDE1 + f_s)*MLO_FILTER_SIZE0 + i,
				weights[wei_off + (j*MLO_FILTER_STRIDE1 + f_s)*MLO_FILTER_SIZE0 + i],
				wei_mem[k*MLO_WEI_SZ + j*MLO_WEI_LCL_WIDTH + i]
			);
		}

#endif
    }
}

void fetchData(uint f_s,
               uint lcl_id,
               uint lcl_scan,
               uint n_reads,
               int in_y,
               uint gbl_in_scan_off,
               __local _FLOAT* bot_mem,
               const __global _FLOAT* bot)
{
    __private _FLOAT in_rd_data[MLO_READ_UNIT];

    for(uint p4 = lcl_id, c_scan = 0; p4 < MLO_N_IN_HORIZ_READS * n_reads * MLO_N_LCL_BATCHS;
        p4 += MLO_GRP_SZ)
    {
        uint b  = 0;
        uint t0 = p4;
#if MLO_N_LCL_BATCHS > 1
        b  = iDiv_legacy(p4, MLO_N_IN_HORIZ_READS * n_reads);
        t0 = iMod(p4, b, MLO_N_IN_HORIZ_READS * n_reads);
#endif
#if MLO_N_IN_HORIZ_READS & (MLO_N_IN_HORIZ_READS - 1)
        c_scan      = iDiv_legacy(t0, MLO_N_IN_HORIZ_READS);
        uint c_pix4 = iMod(t0, c_scan, MLO_N_IN_HORIZ_READS);
#else
        c_scan      = t0 / MLO_N_IN_HORIZ_READS;
        uint c_pix4 = t0 & (MLO_N_IN_HORIZ_READS - 1);
#endif
        int in_scan = (c_scan + lcl_scan) * MLO_FILTER_STRIDE1 + f_s;

        for(uint i = 0; i < MLO_READ_UNIT; ++i)
        {
            in_rd_data[i] = 0;
        }

        if(0 <= in_y + in_scan && in_y + in_scan < MLO_IN_HEIGHT)
        {

            int gbl_off = gbl_in_scan_off + b * MLO_IN_BATCH_STRIDE + in_scan * MLO_IN_STRIDE +
                          c_pix4 * MLO_READ_UNIT;
            const __global _FLOAT* bot_p = &bot[gbl_off];
// still problems with unaligned LDS access
#if MLO_IN_N_PIXS_OFF > 0
            if(c_pix4 == MLO_N_IN_HORIZ_READS - 1)
            {
                uint i = 0;
                for(; i < MLO_IN_N_PIXS_OFF; ++i)
                {
                    in_rd_data[i] = bot_p[i];
                }
                //								for (; i <
                // MLO_READ_UNIT;
                //++i)
                //								{
                //									in_rd_data[i]
                //=
                // 0;
                //								}
            }
            else
#endif
            {

                for(uint i = 0; i < MLO_READ_UNIT; ++i)
                {
                    in_rd_data[i] = bot_p[i];
                }
            }
        }
        int lcl_off =
            (lcl_scan + c_scan) * MLO_IN_LCL_WIDTH + MLO_FILTER_PAD0 + c_pix4 * MLO_READ_UNIT;
        for(uint i = 0; i < MLO_READ_UNIT; ++i)
        {
            bot_mem[lcl_off + i] = in_rd_data[i];
        }
    }
}

void Convolve(uint ex_row,
              uint ex_pix,
              uint l,
              uint m,
              uint wei_h,
              uint bot_h,
              __local _FLOAT* __restrict wei_mem,
              __local _FLOAT* __restrict bot_mem,
              __private _FLOAT_ACCUM* pvt_accum)
{
    // only for 11
    __private _FLOAT wei_vals[MLO_N_LCL_OUT_MAPS * MLO_N_FILTER_SPLITS0];
    __private _FLOAT in_vals[(MLO_OUT_PIX_TILE0 + MLO_N_FILTER_SPLITS0 - 1)];

    // read all weights
    for(uint k = 0; k < MLO_N_LCL_OUT_MAPS; ++k)
    {
        for(uint i = 0; i < wei_h; ++i)
        {
            wei_vals[k * MLO_N_FILTER_SPLITS0 + i] =
                wei_mem[k * MLO_WEI_SZ + m * MLO_WEI_LCL_WIDTH + i * MLO_FILTER_STRIDE0 + l];
        }
    }

    // convolve
    for(uint i = 0; i < bot_h; ++i)
    {
        in_vals[i] = bot_mem[(ex_row + m) * MLO_IN_LCL_WIDTH + ex_pix * MLO_FILTER_STRIDE0 +
                             i * MLO_FILTER_STRIDE0 + l];
    }

    for(uint k = 0; k < MLO_N_LCL_OUT_MAPS; ++k)
    {
        for(uint n = 0; n < MLO_OUT_PIX_TILE0; ++n)
        {

            for(uint i = 0; i < wei_h; ++i)
            {
                _FLOAT in_val  = in_vals[n + i];
                _FLOAT wei_val = wei_vals[k * MLO_N_FILTER_SPLITS0 + i];
                pvt_accum[k * MLO_OUT_PIX_TILE0 + n] +=
                    CVT_FLOAT2ACCUM(wei_val) * CVT_FLOAT2ACCUM(in_val);
#if 0
				if (wei_val * in_val != 0 && ib + b + bb == 0 && k_idx + k == 1 && out_y + ex_row == 0 && ex_pix + n == 0)
				{
					printf("G:c: %d %d %d %d %d %d %d %d %d %d %d %d %f %f %f %f\n",
						f_s,
						out_y,
						ex_row,
						ex_pix,
						m,
						n,
						l,
						i,
						(out_y + ex_row)*MLO_FILTER_STRIDE1 + m*MLO_FILTER_STRIDE1 + f_s - MLO_FILTER_PAD1, // actual input vertical position
						(ex_pix + n)*MLO_FILTER_STRIDE0 + l*MLO_FILTER_STRIDE0 + i - MLO_FILTER_PAD0, // actual input horiz pos (assuming full scan is inside LDS)
						m*MLO_FILTER_STRIDE1 + f_s, // actual filter vet pos
						l*MLO_FILTER_STRIDE0 + i, // actual filter horiz pos
						pvt_accum[(bb*MLO_N_LCL_OUT_MAPS + k) * MLO_OUT_PIX_TILE0 + n],
						wei_val * in_val,
						wei_val,
						in_val
					);
				}

#endif
            }
        }
    }
} // l

/*********************************************************************************************************
// frw algorithm for large filters
// idea:
// process 3 output pixel per wk-item, 19 wk-items per output scan,
// 13 output sacn-line per group of 256
// read (13+2) input scan-lines 4 scan-lines apart from 2 batches
// convolve with 3 filters rows 4 rowes apart from 4(8) filter banks.


**********************************************************************************************************/

__attribute__((reqd_work_group_size(MLO_GRP_SZ0, MLO_GRP_SZ1, MLO_GRP_SZ2))) __kernel void
MIOpenCvFwd11x11(const __global _FLOAT* __restrict bot,
                 const __global _FLOAT* __restrict weights,
#if MLO_CONV_BIAS == 1
                 const __global _FLOAT* __restrict bias,
#endif
                 __global _FLOAT* __restrict top,
                 UNUSED _FLOAT padding_val)
{

    __local _FLOAT lcl_mem[MLO_LCL_MEM_SZ];
    __local _FLOAT* bot_mem = lcl_mem;
    __local _FLOAT* wei_mem = lcl_mem + MLO_TOTAL_IN_LCL_SZ;

    uint lcl_id = get_local_id(0);

    uint ob = get_group_id(0); // output map extent id

    uint k_idx = get_group_id(1) * (MLO_N_LCL_OUT_MAPS); // input map index based

    uint ib_idx = get_group_id(2) * MLO_N_LCL_BATCHS; // batch idx

    uint ib = ib_idx;

    int gbl_in_off   = /*c_idx * MLO_IN_CHANNEL_STRIDE + */ ib * MLO_IN_BATCH_STRIDE;
    uint gbl_wei_off = k_idx * MLO_WEI_BATCH_STRIDE;
    uint out_y       = ob * MLO_OUT_EXTENT1;
    int in_y         = out_y * MLO_FILTER_STRIDE1 - MLO_FILTER_PAD1;
    gbl_in_off += in_y * MLO_IN_STRIDE;

#define MLO_ACCUM_SZ \
    (MLO_OUT_PIX_TILE1 * MLO_OUT_PIX_TILE0 * MLO_N_LCL_OUT_MAPS * MLO_N_LCL_IN_MAPS)

    __private _FLOAT_ACCUM pvt_accum[MLO_ACCUM_SZ];

    // zero out LDS
    for(uint i = lcl_id; i < (MLO_LCL_MEM_SZ); i += MLO_GRP_SZ)
    {
        lcl_mem[i] = 0;
    }

// processing arrangement
#if MLO_PROCESSING_WIDTH & (MLO_PROCESSING_WIDTH - 1)
    uint ex_row = iDiv_legacy(lcl_id, MLO_PROCESSING_WIDTH);
    uint ex_col = iMod(lcl_id, ex_row, MLO_PROCESSING_WIDTH);
#else
    uint ex_row     = lcl_id / MLO_PROCESSING_WIDTH;
    uint ex_col     = lcl_id & (MLO_PROCESSING_WIDTH - 1);
#if MLO_PROCESSING_WIDTH >= 64
    ex_row          = uniform(ex_row);
#endif
#endif
    uint ex_pix = ex_col * MLO_OUT_PIX_TILE0;

    // over all batches

    for(uint b = 0; b < MLO_N_BATCH_LOOPS; ++b, gbl_in_off += MLO_IN_BATCH_STRIDE)
    {

        int gbl_in_scan_off0 = gbl_in_off;

        // generate pixels from all MLO_N_LCL_OUT_MAPS output maps

        for(uint i = 0; i < MLO_ACCUM_SZ; ++i)
        {
            pvt_accum[i] = CVT_FLOAT2ACCUM(0);
        }

// all input maps
#ifdef __AMDGCN__
#pragma unroll 4
#endif
        for(uint c = 0, gbl_in_scan_off = gbl_in_scan_off0; c < MLO_N_INPUTS;
            ++c, gbl_in_scan_off += MLO_IN_CHANNEL_STRIDE)
        {
            uint f_s = 0;
            for(; f_s < MLO_FILTER_STRIDE1 - 1; ++f_s)
            {

                barrier(CLK_LOCAL_MEM_FENCE);

                // get a set of horizaontal taps
                fetchWeights(c, k_idx, f_s, lcl_id, MLO_WEI_SZ, gbl_wei_off, wei_mem, weights);

                // fetch a set of input scanlines

                uint n_reads = MLO_IN_LCL_HEIGHT; // ((ob == 0 && (f_s < MLO_FILTER_PAD1)) || (ob ==
                                                  // get_local_size(0) - 1 && (MLO_FILTER_STRIDE1 -
                                                  // f_s) < MLO_FILTER_PAD1)) ? MLO_IN_LCL_HEIGHT -
                                                  // 1 : MLO_IN_LCL_HEIGHT;
                uint lcl_scan = 0;                // (ob == 0 && (f_s < MLO_FILTER_PAD1)) ? 1 : 0;

                fetchData(f_s, lcl_id, lcl_scan, n_reads, in_y, gbl_in_scan_off, bot_mem, bot);

                barrier(CLK_LOCAL_MEM_FENCE);

// convolution
// along vertical filter
#pragma unroll
                for(uint m = 0; m < MLO_N_FILTER_SPLITS1; ++m)
                {

                    // first 3 splits
                    uint l;
                    for(l = 0; l < MLO_FILTER_STRIDE0 - 1; ++l)
                    {

                        Convolve(ex_row,
                                 ex_pix,
                                 l,
                                 m,
                                 (MLO_N_FILTER_SPLITS0),
                                 (MLO_OUT_PIX_TILE0 + MLO_N_FILTER_SPLITS0 - 1),
                                 wei_mem,
                                 bot_mem,
                                 pvt_accum);
                    } // l
                      // 4th

                    Convolve(ex_row,
                             ex_pix,
                             l,
                             m,
                             (MLO_N_FILTER_SPLITS0 - 1),
                             (MLO_OUT_PIX_TILE0 + MLO_N_FILTER_SPLITS0 - 2),
                             wei_mem,
                             bot_mem,
                             pvt_accum);

                } // m

            } // f_s

            // last f_s
            {

                barrier(CLK_LOCAL_MEM_FENCE);

#define MLO_WEI_READ ((MLO_N_FILTER_SPLITS1 - 1) * MLO_WEI_LCL_WIDTH)
                // fetch a set of weight vertical taps
                fetchWeights(c, k_idx, f_s, lcl_id, (MLO_WEI_READ), gbl_wei_off, wei_mem, weights);

                // fetch a set of input scanlines

                uint n_reads = MLO_IN_LCL_HEIGHT - 1; // ((ob == 0 && (f_s < MLO_FILTER_PAD1)) ||
                                                      // (ob == get_local_size(0) - 1 &&
                                                      // (MLO_FILTER_STRIDE1 - f_s) <
                                                      // MLO_FILTER_PAD1)) ? MLO_IN_LCL_HEIGHT - 1 :
                                                      // MLO_IN_LCL_HEIGHT;
                uint lcl_scan = 0; // (ob == 0 && (f_s < MLO_FILTER_PAD1)) ? 1 : 0;

                fetchData(f_s, lcl_id, lcl_scan, n_reads, in_y, gbl_in_scan_off, bot_mem, bot);

                barrier(CLK_LOCAL_MEM_FENCE);

// convolution
// along vertical filter
#pragma unroll
                for(uint m = 0; m < MLO_N_FILTER_SPLITS1 - 1; ++m)
                {

                    // first 3 splits
                    uint l;
                    for(l = 0; l < MLO_FILTER_STRIDE0 - 1; ++l)
                    {
                        Convolve(ex_row,
                                 ex_pix,
                                 l,
                                 m,
                                 (MLO_N_FILTER_SPLITS0),
                                 (MLO_OUT_PIX_TILE0 + MLO_N_FILTER_SPLITS0 - 1),
                                 wei_mem,
                                 bot_mem,
                                 pvt_accum);

                    } // l
                      // 4th

                    Convolve(ex_row,
                             ex_pix,
                             l,
                             m,
                             (MLO_N_FILTER_SPLITS0 - 1),
                             (MLO_OUT_PIX_TILE0 + MLO_N_FILTER_SPLITS0 - 2),
                             wei_mem,
                             bot_mem,
                             pvt_accum);

                } // m

            } // f_s

        } // c

        //			for (int bb = 0; bb < MLO_N_LCL_BATCHS && ex_row < MLO_OUT_EXTENT1
        //&&
        //(out_y + ex_row) < MLO_OUT_HEIGHT; ++bb)
        {
            for(uint k = 0; k < MLO_N_LCL_OUT_MAPS; ++k)
            {
                // write out
                // inputs are outputs
                uint out_off = (ib + b) * MLO_OUT_BATCH_STRIDE +
                               (k_idx + k) * MLO_OUT_CHANNEL_STRIDE +
                               (out_y + ex_row) * MLO_OUT_STRIDE + ex_pix;
                __global _FLOAT* top_p = &top[out_off];
                for(uint i = 0; i < MLO_OUT_PIX_TILE0; ++i)
                {
                    if((k_idx + k) < MLO_N_OUTPUTS && ex_row < MLO_OUT_EXTENT1 &&
                       (out_y + ex_row) < MLO_OUT_HEIGHT && ex_pix + i < MLO_OUT_WIDTH)
                    {
                        top_p[i] = CVT_ACCUM2FLOAT(pvt_accum[k * MLO_OUT_PIX_TILE0 + i]);
                    }
                }
            }
        }

    } // b
}

/*****************************************************
        2nd pass
******************************************************/
#undef MLO_LCL_MEM_SZ
#undef MLO_TOTAL_IN_LCL_SZ
#undef MLO_IN_LCL_SZ
#undef MLO_IN_LCL_HEIGHT
#undef MLO_OUT_EXTENT1
#undef MLO_N_LCL_BATCHS

#define MLO_N_LCL_BATCHS MLO_N_LCL_BATCHS_PASS2
#define MLO_OUT_EXTENT1 (MLO_LAST_OUT_EXTENT1)
#define MLO_IN_LCL_HEIGHT (MLO_OUT_EXTENT1 + MLO_N_FILTER_SPLITS1 - 1)
#define MLO_IN_LCL_SZ (MLO_IN_LCL_WIDTH * MLO_IN_LCL_HEIGHT)
// LDS size
#define MLO_TOTAL_IN_LCL_SZ (MLO_N_LCL_BATCHS * MLO_IN_LCL_SZ * MLO_N_LCL_IN_MAPS)
#define MLO_LCL_MEM_SZ (MLO_WEI_LCL_SZ + MLO_TOTAL_IN_LCL_SZ)

void fetchData2(uint ib,
                uint f_s,
                uint lcl_id,
                uint lcl_scan,
                uint n_reads,
                int in_y,
                int gbl_in_scan_off,
                __local _FLOAT* bot_mem,
                const __global _FLOAT* bot)
{
    __private _FLOAT in_rd_data[MLO_READ_UNIT];

    for(uint p4 = lcl_id, c_scan = 0; p4 < MLO_N_IN_HORIZ_READS * n_reads * MLO_N_LCL_BATCHS;
        p4 += MLO_GRP_SZ)
    {
        uint b  = 0;
        uint t0 = p4;
#if MLO_N_LCL_BATCHS > 1
        b  = iDiv_legacy(p4, MLO_N_IN_HORIZ_READS * n_reads);
        t0 = iMod(p4, b, MLO_N_IN_HORIZ_READS * n_reads);
#endif
#if MLO_N_IN_HORIZ_READS & (MLO_N_IN_HORIZ_READS - 1)
        c_scan      = iDiv_legacy(t0, MLO_N_IN_HORIZ_READS);
        uint c_pix4 = iMod(t0, c_scan, MLO_N_IN_HORIZ_READS);
#else
        c_scan      = t0 / MLO_N_IN_HORIZ_READS;
        uint c_pix4 = t0 & (MLO_N_IN_HORIZ_READS - 1);
#endif
        int in_scan = (c_scan + lcl_scan) * MLO_FILTER_STRIDE1 + f_s;

        for(uint i = 0; i < MLO_READ_UNIT; ++i)
        {
            in_rd_data[i] = 0;
        }

        if(0 <= in_y + in_scan && in_y + in_scan < MLO_IN_HEIGHT && b < MLO_N_LCL_BATCHS &&
           (ib + b) < MLO_BATCH_SZ)
        {

            int gbl_off = gbl_in_scan_off + b * MLO_IN_BATCH_STRIDE + in_scan * MLO_IN_STRIDE +
                          c_pix4 * MLO_READ_UNIT;
            const __global _FLOAT* bot_p = &bot[gbl_off];
// still problems with unaligned LDS access
#if MLO_IN_N_PIXS_OFF > 0
            if(c_pix4 == MLO_N_IN_HORIZ_READS - 1)
            {
                uint i = 0;
                for(; i < MLO_IN_N_PIXS_OFF; ++i)
                {
                    in_rd_data[i] = bot_p[i];
                }
                //								for (; i <
                // MLO_READ_UNIT;
                //++i)
                //								{
                //									in_rd_data[i]
                //=
                // 0;
                //								}
            }
            else
#endif
            {

                for(uint i = 0; i < MLO_READ_UNIT; ++i)
                {
                    in_rd_data[i] = bot_p[i];
                }
            }
        }

        if(b < MLO_N_LCL_BATCHS)
        {
            int lcl_off = b * MLO_IN_LCL_SZ + (lcl_scan + c_scan) * MLO_IN_LCL_WIDTH +
                          MLO_FILTER_PAD0 + c_pix4 * MLO_READ_UNIT;
            for(uint i = 0; i < MLO_READ_UNIT; ++i)
            {
                bot_mem[lcl_off + i] = in_rd_data[i];
            }
        }
    }
}

void Convolve2(uint b,
               uint ex_row,
               uint ex_pix,
               uint l,
               uint m,
               uint wei_h,
               uint bot_h,
               __local _FLOAT* __restrict wei_mem,
               __local _FLOAT* __restrict bot_mem,
               __private _FLOAT_ACCUM* pvt_accum)
{
    // only for 11
    __private _FLOAT wei_vals[MLO_N_LCL_OUT_MAPS * MLO_N_FILTER_SPLITS0];
    __private _FLOAT in_vals[(MLO_OUT_PIX_TILE0 + MLO_N_FILTER_SPLITS0 - 1)];

    // read all weights
    for(uint k = 0; k < MLO_N_LCL_OUT_MAPS; ++k)
    {
        for(uint i = 0; i < wei_h; ++i)
        {
            wei_vals[k * MLO_N_FILTER_SPLITS0 + i] =
                wei_mem[k * MLO_WEI_SZ + m * MLO_WEI_LCL_WIDTH + i * MLO_FILTER_STRIDE0 + l];
        }
    }

    // convolve
    for(uint i = 0; i < bot_h; ++i)
    {
        in_vals[i] = bot_mem[b * MLO_IN_LCL_SZ + (ex_row + m) * MLO_IN_LCL_WIDTH +
                             ex_pix * MLO_FILTER_STRIDE0 + i * MLO_FILTER_STRIDE0 + l];
    }

    for(uint k = 0; k < MLO_N_LCL_OUT_MAPS; ++k)
    {
        for(uint n = 0; n < MLO_OUT_PIX_TILE0; ++n)
        {

            for(uint i = 0; i < wei_h; ++i)
            {
                _FLOAT in_val  = in_vals[n + i];
                _FLOAT wei_val = wei_vals[k * MLO_N_FILTER_SPLITS0 + i];
                pvt_accum[k * MLO_OUT_PIX_TILE0 + n] +=
                    CVT_FLOAT2ACCUM(wei_val) * CVT_FLOAT2ACCUM(in_val);
#if 0
				if (wei_val * in_val != 0 && ib + b + bb == 0 && k_idx + k == 1 && out_y + ex_row == 0 && ex_pix + n == 0)
				{
					printf("G:c: %d %d %d %d %d %d %d %d %d %d %d %d %f %f %f %f\n",
						f_s,
						out_y,
						ex_row,
						ex_pix,
						m,
						n,
						l,
						i,
						(out_y + ex_row)*MLO_FILTER_STRIDE1 + m*MLO_FILTER_STRIDE1 + f_s - MLO_FILTER_PAD1, // actual input vertical position
						(ex_pix + n)*MLO_FILTER_STRIDE0 + l*MLO_FILTER_STRIDE0 + i - MLO_FILTER_PAD0, // actual input horiz pos (assuming full scan is inside LDS)
						m*MLO_FILTER_STRIDE1 + f_s, // actual filter vet pos
						l*MLO_FILTER_STRIDE0 + i, // actual filter horiz pos
						pvt_accum[(bb*MLO_N_LCL_OUT_MAPS + k) * MLO_OUT_PIX_TILE0 + n],
						wei_val * in_val,
						wei_val,
						in_val
					);
				}

#endif
            }
        }
    }
} // l

__attribute__((reqd_work_group_size(MLO_GRP_SZ0, MLO_GRP_SZ1, MLO_GRP_SZ2))) __kernel void
MIOpenCvFwd11x11_2(const __global _FLOAT* __restrict bot,
                   const __global _FLOAT* __restrict weights,
#if MLO_CONV_BIAS == 1
                   const __global _FLOAT* __restrict bias,
#endif
                   __global _FLOAT* __restrict top,
                   UNUSED _FLOAT padding_val)
{

    __local _FLOAT lcl_mem[MLO_LCL_MEM_SZ];
    __local _FLOAT* bot_mem = lcl_mem;
    __local _FLOAT* wei_mem = lcl_mem + MLO_TOTAL_IN_LCL_SZ;

    uint lcl_id = get_local_id(0);

    uint k_idx = get_group_id(1) * (MLO_N_LCL_OUT_MAPS); // input map index based

    uint ib_idx = get_group_id(2) * MLO_N_LCL_BATCHS; // batch idx

    uint ib = ib_idx;

    int gbl_in_off   = /*c_idx * MLO_IN_CHANNEL_STRIDE + */ ib * MLO_IN_BATCH_STRIDE;
    uint gbl_wei_off = k_idx * MLO_WEI_BATCH_STRIDE;

    // last extent
    // the major part of the output map has been processed in the previous pass to avoid the
    // granularity loss
    int out_y = MLO_OUT_HEIGHT - MLO_LAST_OUT_EXTENT1;

    int in_y = out_y * MLO_FILTER_STRIDE1 - MLO_FILTER_PAD1;
    gbl_in_off += in_y * MLO_IN_STRIDE;

#define MLO_ACCUM_SZ \
    (MLO_OUT_PIX_TILE1 * MLO_OUT_PIX_TILE0 * MLO_N_LCL_OUT_MAPS * MLO_N_LCL_IN_MAPS)

    __private _FLOAT_ACCUM pvt_accum[MLO_ACCUM_SZ];

    // zero out LDS
    for(uint i = lcl_id; i < (MLO_LCL_MEM_SZ); i += MLO_GRP_SZ)
    {
        lcl_mem[i] = 0;
    }

// processing arrangement
// batch
#if(MLO_PROCESSING_WIDTH * MLO_LAST_OUT_EXTENT1) & (MLO_PROCESSING_WIDTH * MLO_LAST_OUT_EXTENT1 - 1)
    uint bb = iDiv_legacy(lcl_id, (MLO_PROCESSING_WIDTH * MLO_LAST_OUT_EXTENT1));
    uint t0 = iMod(lcl_id, bb, (MLO_PROCESSING_WIDTH * MLO_LAST_OUT_EXTENT1));
#elif(MLO_PROCESSING_WIDTH * MLO_LAST_OUT_EXTENT1) != 0
    uint bb         = lcl_id / (MLO_PROCESSING_WIDTH * MLO_LAST_OUT_EXTENT1);
    uint t0         = lcl_id & ((MLO_PROCESSING_WIDTH * MLO_LAST_OUT_EXTENT1) - 1);
#if(MLO_PROCESSING_WIDTH * MLO_LAST_OUT_EXTENT1) >= 64
    bb              = uniform(bb);
#endif
#else
    uint bb = lcl_id;
    uint t0 = 0;
#endif
#if MLO_PROCESSING_WIDTH & (MLO_PROCESSING_WIDTH - 1)
    uint ex_row = iDiv_legacy(t0, MLO_PROCESSING_WIDTH);
    uint ex_col = iMod(t0, ex_row, MLO_PROCESSING_WIDTH);
#else
    uint ex_row     = t0 / MLO_PROCESSING_WIDTH;
    uint ex_col     = t0 & (MLO_PROCESSING_WIDTH - 1);
#endif
    uint ex_pix = ex_col * MLO_OUT_PIX_TILE0;

    // over all batches

    for(uint b = 0; b < MLO_N_BATCH_LOOPS; ++b, gbl_in_off += MLO_IN_BATCH_STRIDE)
    {

        int gbl_in_scan_off0 = gbl_in_off;

        // generate pixels from all MLO_N_LCL_OUT_MAPS output maps

        for(uint i = 0; i < MLO_ACCUM_SZ; ++i)
        {
            pvt_accum[i] = CVT_FLOAT2ACCUM(0);
        }

// all input maps
#ifdef __AMDGCN__
#pragma unroll 4
#endif
        for(uint c = 0, gbl_in_scan_off = gbl_in_scan_off0; c < MLO_N_INPUTS;
            ++c, gbl_in_scan_off += MLO_IN_CHANNEL_STRIDE)
        {
            uint f_s = 0;
            for(; f_s < MLO_FILTER_STRIDE1 - 1; ++f_s)
            {

                barrier(CLK_LOCAL_MEM_FENCE);

                // get a set of horizaontal taps
                fetchWeights(c, k_idx, f_s, lcl_id, MLO_WEI_SZ, gbl_wei_off, wei_mem, weights);

                // fetch a set of input scanlines

                uint n_reads = MLO_IN_LCL_HEIGHT; // ((ob == 0 && (f_s < MLO_FILTER_PAD1)) || (ob ==
                                                  // get_local_size(0) - 1 && (MLO_FILTER_STRIDE1 -
                                                  // f_s) < MLO_FILTER_PAD1)) ? MLO_IN_LCL_HEIGHT -
                                                  // 1 : MLO_IN_LCL_HEIGHT;
                uint lcl_scan = 0;                // (ob == 0 && (f_s < MLO_FILTER_PAD1)) ? 1 : 0;

                fetchData2(
                    (ib + b), f_s, lcl_id, lcl_scan, n_reads, in_y, gbl_in_scan_off, bot_mem, bot);

                barrier(CLK_LOCAL_MEM_FENCE);

// convolution
// along vertical filter
#pragma unroll
                for(uint m = 0; m < MLO_N_FILTER_SPLITS1; ++m)
                {

                    // first 3 splits
                    uint l;
                    for(l = 0; l < MLO_FILTER_STRIDE0 - 1; ++l)
                    {

                        Convolve2(bb,
                                  ex_row,
                                  ex_pix,
                                  l,
                                  m,
                                  (MLO_N_FILTER_SPLITS0),
                                  (MLO_OUT_PIX_TILE0 + MLO_N_FILTER_SPLITS0 - 1),
                                  wei_mem,
                                  bot_mem,
                                  pvt_accum);
                    } // l
                      // 4th

                    Convolve2(bb,
                              ex_row,
                              ex_pix,
                              l,
                              m,
                              (MLO_N_FILTER_SPLITS0 - 1),
                              (MLO_OUT_PIX_TILE0 + MLO_N_FILTER_SPLITS0 - 2),
                              wei_mem,
                              bot_mem,
                              pvt_accum);

                } // m

            } // f_s

            // last f_s
            {

                barrier(CLK_LOCAL_MEM_FENCE);

#define MLO_WEI_READ ((MLO_N_FILTER_SPLITS1 - 1) * MLO_WEI_LCL_WIDTH)
                // fetch a set of weight vertical taps

                fetchWeights(c, k_idx, f_s, lcl_id, (MLO_WEI_READ), gbl_wei_off, wei_mem, weights);

                // fetch a set of input scanlines

                uint n_reads = MLO_IN_LCL_HEIGHT - 1; // ((ob == 0 && (f_s < MLO_FILTER_PAD1)) ||
                                                      // (ob == get_local_size(0) - 1 &&
                                                      // (MLO_FILTER_STRIDE1 - f_s) <
                                                      // MLO_FILTER_PAD1)) ? MLO_IN_LCL_HEIGHT - 1 :
                                                      // MLO_IN_LCL_HEIGHT;
                uint lcl_scan = 0; // (ob == 0 && (f_s < MLO_FILTER_PAD1)) ? 1 : 0;

                fetchData2(
                    (ib + b), f_s, lcl_id, lcl_scan, n_reads, in_y, gbl_in_scan_off, bot_mem, bot);

                barrier(CLK_LOCAL_MEM_FENCE);

// convolution
// along vertical filter
#pragma unroll
                for(uint m = 0; m < MLO_N_FILTER_SPLITS1 - 1; ++m)
                {

                    // first 3 splits
                    uint l;
                    for(l = 0; l < MLO_FILTER_STRIDE0 - 1; ++l)
                    {
                        Convolve2(bb,
                                  ex_row,
                                  ex_pix,
                                  l,
                                  m,
                                  (MLO_N_FILTER_SPLITS0),
                                  (MLO_OUT_PIX_TILE0 + MLO_N_FILTER_SPLITS0 - 1),
                                  wei_mem,
                                  bot_mem,
                                  pvt_accum);

                    } // l
                      // 4th

                    Convolve2(bb,
                              ex_row,
                              ex_pix,
                              l,
                              m,
                              (MLO_N_FILTER_SPLITS0 - 1),
                              (MLO_OUT_PIX_TILE0 + MLO_N_FILTER_SPLITS0 - 2),
                              wei_mem,
                              bot_mem,
                              pvt_accum);

                } // m

            } // f_s

        } // c

        for(uint k = 0; k < MLO_N_LCL_OUT_MAPS; ++k)
        {
            // write out
            // inputs are outputs
            uint out_off = (ib + bb + b) * MLO_OUT_BATCH_STRIDE +
                           (k_idx + k) * MLO_OUT_CHANNEL_STRIDE +
                           (out_y + ex_row) * MLO_OUT_STRIDE + ex_pix;
            __global _FLOAT* top_p = &top[out_off];
            for(uint i = 0; i < MLO_OUT_PIX_TILE0; ++i)
            {
                if((ib + bb + b) < MLO_BATCH_SZ && bb < MLO_N_LCL_BATCHS &&
                   (k_idx + k) < MLO_N_OUTPUTS && ex_row < MLO_LAST_OUT_EXTENT1 &&
                   (out_y + ex_row) < MLO_OUT_HEIGHT && ex_pix + i < MLO_OUT_WIDTH)
                {
                    top_p[i] = CVT_ACCUM2FLOAT(pvt_accum[k * MLO_OUT_PIX_TILE0 + i]);
                }

#if 0
				if (out_off + i == 0)
				{
					printf("G:p2:o: %d %d %d %d\n",
						lcl_id,
						out_y,
						ex_row,
						ex_pix
					);
				}
#endif
            }
        }

    } // b
}

#else

#define MLO_N_TILES1 \
    ((MLO_OUT_HEIGHT + MLO_OUT_PIX_TILE1 - 1 + 2 * MLO_FILTER_PAD1) / MLO_OUT_PIX_TILE1)
#define MLO_N_TILES0 \
    ((MLO_OUT_WIDTH + MLO_OUT_PIX_TILE0 - 1 + 2 * MLO_FILTER_PAD0) / MLO_OUT_PIX_TILE0)

void MoveWeightsIn(__local _FLOAT* lcl_mem,
                   uint lcl_wei_write_off,
                   const __global _FLOAT* weights,
                   uint gbl_wei_off,
                   uint lcl_id)
{
    barrier(CLK_LOCAL_MEM_FENCE);

    for(uint i = lcl_id; i < MLO_N_LCL_OUT_MAPS * MLO_FILTER_SIZE1 * MLO_FILTER_SIZE0;
        i += MLO_GRP_SZ)
    {
        lcl_mem[lcl_wei_write_off + i] = weights[gbl_wei_off + i];
    }
    barrier(CLK_LOCAL_MEM_FENCE);
}

#if defined(__AMDGCN__)

void MoveDataIn(_FLOAT proc_dat[MLO_IN_PIX_TILE1][MLO_IN_PIX_TILE0],
                __local _FLOAT* lcl_mem,
                const __global _FLOAT* bot,
                uint gbl_in_off,
                int grp_in_y,
                int grp_in_x,
                uint lcl_in_y,
                uint lcl_in_x)
{
    uint lcl_id = get_local_id(0);

    barrier(CLK_LOCAL_MEM_FENCE);

    // TODO: 	MLO_N_LCL_IN_MAPS

    for(uint i = lcl_id; i < MLO_N_IN_BWD_VERT_READS * MLO_N_IN_BWD_HORIZ_READS; i += MLO_GRP_SZ)
    {
        uint in_y = i / MLO_N_IN_BWD_HORIZ_READS;
        uint in_x = i % MLO_N_IN_BWD_HORIZ_READS;

        int in_run_y = grp_in_y + (int)in_y;
        int in_run_x = grp_in_x + (int)in_x;

        bool out_of_range =
            (in_run_y < 0 || in_run_y >= MLO_IN_HEIGHT || in_run_x < 0 || in_run_x >= MLO_IN_WIDTH);
        uint bot_off = (out_of_range) ? 0 : in_run_y * MLO_IN_STRIDE + in_run_x;

        _FLOAT dat = bot[gbl_in_off + bot_off];
        lcl_mem[i] = (out_of_range) ? 0 : dat;
    }
    barrier(CLK_LOCAL_MEM_FENCE);

    for(uint j = 0; j < MLO_IN_PIX_TILE1; ++j)
    {
        for(int i = 0; i < MLO_IN_PIX_TILE0; ++i)
        {
            uint lcl_off   = (lcl_in_y + j) * MLO_N_IN_BWD_HORIZ_READS + lcl_in_x + i;
            proc_dat[j][i] = lcl_mem[lcl_off];
        }
    }
}

#else

void MoveDataIn(_FLOAT proc_dat[MLO_IN_PIX_TILE1][MLO_IN_PIX_TILE0],
                const __global _FLOAT* bot,
                uint gbl_in_off,
                const uint gbl_in_offs[MLO_IN_PIX_TILE1][MLO_IN_PIX_TILE0],
                const _FLOAT* mask_out_of_range)
{
    for(int j = MLO_IN_PIX_TILE1 - 1; j >= 0; --j)
    {
        for(int i = MLO_IN_PIX_TILE0 - 1; i >= 0; --i)
        {
            _FLOAT dat =
                bot[gbl_in_off + gbl_in_offs[j][i]] * mask_out_of_range[j * MLO_IN_PIX_TILE0 + i];
            proc_dat[j][i] = dat;
        }
    }
}
#endif

void Convolve(_FLOAT_ACCUM* pvt_accum,
              const _FLOAT proc_dat[MLO_IN_PIX_TILE1][MLO_IN_PIX_TILE0],
              const __local _FLOAT* lcl_mem,
              uint lcl_wei_read_off
#if DBG_PRINTF == 1
              ,
              int map_out_y,
              int map_out_x
#endif
              )
{
    // convolve
    for(uint k = 0; k < MLO_N_LCL_OUT_MAPS; ++k)
    {
        int jj = MLO_N_FILTER_SPLITS1 - 1;
        for(; jj > 0; --jj)
        {
            for(uint j = 0; j < MLO_OUT_PIX_TILE1; ++j)
            {

                int ii = MLO_N_FILTER_SPLITS0 - 1;
                for(; ii > 0; --ii)
                {
                    for(uint i = 0; i < MLO_OUT_PIX_TILE0; ++i)
                    {
                        uint pvt_off = (k * MLO_OUT_PIX_TILE1 + j) * MLO_OUT_PIX_TILE0 + i;
                        uint y       = ((MLO_N_FILTER_SPLITS1 - 1 - jj) * MLO_FILTER_STRIDE1 +
                                  j % MLO_FILTER_STRIDE1);
                        uint x = (MLO_N_FILTER_SPLITS0 - 1 - ii) * MLO_FILTER_STRIDE0 +
                                 i % MLO_FILTER_STRIDE0;
                        uint lcl_off = lcl_wei_read_off + k * MLO_FILTER_SIZE1 * MLO_FILTER_SIZE0 +
                                       y * MLO_FILTER_SIZE0 + x;
                        pvt_accum[pvt_off] +=
                            CVT_FLOAT2ACCUM(proc_dat[j / MLO_FILTER_STRIDE1 + jj]
                                                    [i / MLO_FILTER_STRIDE0 + ii]) *
                            CVT_FLOAT2ACCUM(lcl_mem[lcl_off]);
#if 0

						if (k == 0 && map_out_x + (int)i == 0 && map_out_y + (int)j == 66)
						{
							printf("K:c0:%d %d %d %d %d %d %d %d    %9.7f %9.7f %9.7f %9.7f\n",
								jj,
								ii,
								y,
								x,
								pvt_off,
								j / MLO_FILTER_STRIDE1 + jj,
								i / MLO_FILTER_STRIDE0 + ii,
								lcl_off,
								pvt_accum[pvt_off],
								proc_dat[j / MLO_FILTER_STRIDE1 + jj][i / MLO_FILTER_STRIDE0 + ii] * lcl_mem[lcl_off],
								proc_dat[j / MLO_FILTER_STRIDE1 + jj][i / MLO_FILTER_STRIDE0 + ii],
								lcl_mem[lcl_off]
							);
						}
#endif
                    }
                }
                //					for (; ii >= 0; --ii)

                {
                    for(uint im = 0; im < MLO_TILE_REPLICATE0; ++im)
                    {
                        for(uint i = im * MLO_FILTER_STRIDE0; i < (im + 1) * MLO_FILTER_STRIDE0 - 1;
                            ++i)
                        {
                            uint pvt_off = (k * MLO_OUT_PIX_TILE1 + j) * MLO_OUT_PIX_TILE0 + i;
                            uint y       = ((MLO_N_FILTER_SPLITS1 - 1 - jj) * MLO_FILTER_STRIDE1 +
                                      j % MLO_FILTER_STRIDE1);
                            uint x = (MLO_N_FILTER_SPLITS0 - 1 - ii) * MLO_FILTER_STRIDE0 +
                                     i % MLO_FILTER_STRIDE0;
                            uint lcl_off = lcl_wei_read_off +
                                           k * MLO_FILTER_SIZE1 * MLO_FILTER_SIZE0 +
                                           y * MLO_FILTER_SIZE0 + x;
                            pvt_accum[pvt_off] +=
                                CVT_FLOAT2ACCUM(proc_dat[j / MLO_FILTER_STRIDE1 + jj]
                                                        [i / MLO_FILTER_STRIDE0 + ii]) *
                                CVT_FLOAT2ACCUM(lcl_mem[lcl_off]);
#if 0

							if (k == 0 && map_out_x + (int)i == 0 && map_out_y + (int)j == 66)
							{
								printf("K:c1:%d %d %d %d %d %d %d %d    %9.7f %9.7f %9.7f %9.7f\n",
									jj,
									ii,
									y,
									x,
									pvt_off,
									j / MLO_FILTER_STRIDE1 + jj,
									i / MLO_FILTER_STRIDE0 + ii,
									lcl_off,
									pvt_accum[pvt_off],
									proc_dat[j / MLO_FILTER_STRIDE1 + jj][i / MLO_FILTER_STRIDE0 + ii] * lcl_mem[lcl_off],
									proc_dat[j / MLO_FILTER_STRIDE1 + jj][i / MLO_FILTER_STRIDE0 + ii],
									lcl_mem[lcl_off]
								);
							}
#endif
                        } //  for (uint i = im*MLO_FILTER_STRIDE0; i < (im+1)*MLO_FILTER_STRIDE0 -
                          //  1; ++i)
                    }     // for (uint im = 0; im < MLO_TILE_REPLICATE0; ++im)
                }
            }
        }
        //			for (; jj > 0; --jj)
        {
            for(uint jm = 0; jm < MLO_TILE_REPLICATE1; ++jm)
            {
                for(uint j = jm * MLO_FILTER_STRIDE1; j < (jm + 1) * MLO_FILTER_STRIDE1 - 1; ++j)
                {

                    int ii = MLO_N_FILTER_SPLITS0 - 1;
                    for(; ii > 0; --ii)
                    {
                        for(uint i = 0; i < MLO_OUT_PIX_TILE0; ++i)
                        {
                            uint pvt_off = (k * MLO_OUT_PIX_TILE1 + j) * MLO_OUT_PIX_TILE0 + i;
                            uint y       = ((MLO_N_FILTER_SPLITS1 - 1 - jj) * MLO_FILTER_STRIDE1 +
                                      j % MLO_FILTER_STRIDE1);
                            uint x = (MLO_N_FILTER_SPLITS0 - 1 - ii) * MLO_FILTER_STRIDE0 +
                                     i % MLO_FILTER_STRIDE0;
                            uint lcl_off = lcl_wei_read_off +
                                           k * MLO_FILTER_SIZE1 * MLO_FILTER_SIZE0 +
                                           y * MLO_FILTER_SIZE0 + x;
                            pvt_accum[pvt_off] +=
                                CVT_FLOAT2ACCUM(proc_dat[j / MLO_FILTER_STRIDE1 + jj]
                                                        [i / MLO_FILTER_STRIDE0 + ii]) *
                                CVT_FLOAT2ACCUM(lcl_mem[lcl_off]);
#if 0

							if (k == 0 && map_out_x + (int)i == 0 && map_out_y + (int)j == 66)
							{
								printf("K:c0:%d %d %d %d %d %d    %f %f %f %f\n",
									jj,
									ii,
									y,
									x,
									pvt_off,
									lcl_off,
									pvt_accum[pvt_off],
									proc_dat[j / MLO_FILTER_STRIDE1 + jj][i / MLO_FILTER_STRIDE0 + ii] * lcl_mem[lcl_off],
									proc_dat[j / MLO_FILTER_STRIDE1 + jj][i / MLO_FILTER_STRIDE0 + ii],
									lcl_mem[lcl_off]
								);
							}
#endif

                        } // for (uint i = 0; i < MLO_OUT_PIX_TILE0; ++i)
                    }     // for (; ii > 0; --ii)
                          //					for (; ii >= 0; --ii)
                    {
                        for(uint im = 0; im < MLO_TILE_REPLICATE0; ++im)
                        {
                            for(uint i = im * MLO_FILTER_STRIDE0;
                                i < (im + 1) * MLO_FILTER_STRIDE0 - 1;
                                ++i)
                            {
                                uint pvt_off = (k * MLO_OUT_PIX_TILE1 + j) * MLO_OUT_PIX_TILE0 + i;
                                uint y = ((MLO_N_FILTER_SPLITS1 - 1 - jj) * MLO_FILTER_STRIDE1 +
                                          j % MLO_FILTER_STRIDE1);
                                uint x = (MLO_N_FILTER_SPLITS0 - 1 - ii) * MLO_FILTER_STRIDE0 +
                                         i % MLO_FILTER_STRIDE0;
                                uint lcl_off = lcl_wei_read_off +
                                               k * MLO_FILTER_SIZE1 * MLO_FILTER_SIZE0 +
                                               y * MLO_FILTER_SIZE0 + x;
                                pvt_accum[pvt_off] +=
                                    CVT_FLOAT2ACCUM(proc_dat[j / MLO_FILTER_STRIDE1 + jj]
                                                            [i / MLO_FILTER_STRIDE0 + ii]) *
                                    CVT_FLOAT2ACCUM(lcl_mem[lcl_off]);
#if 0

								if (k == 0 && map_out_x + (int)i == 0 && map_out_y + (int)j == 66)
								{
									printf("K:c0:%d %d %d %d %d %d    %f %f %f %f\n",
										jj,
										ii,
										y,
										x,
										pvt_off,
										lcl_off,
										pvt_accum[pvt_off],
										proc_dat[j / MLO_FILTER_STRIDE1 + jj][i / MLO_FILTER_STRIDE0 + ii] * lcl_mem[lcl_off],
										proc_dat[j / MLO_FILTER_STRIDE1 + jj][i / MLO_FILTER_STRIDE0 + ii],
										lcl_mem[lcl_off]
									);
								}
#endif
                            } // for (uint i = im*MLO_FILTER_STRIDE0; i < (im +
                              // 1)*MLO_FILTER_STRIDE0 - 1; ++i)
                        }     // for (uint im = 0; im < MLO_TILE_REPLICATE0; ++im)
                    }
                } // for (uint j = 0; j < MLO_OUT_PIX_TILE1 - 1; ++j)
            }     // for (uint jm = 0; jm < MLO_TILE_REPLICATE1; ++jm)
        }         // for (; jj > 0; --jj)

    } // for (uint k = 0; k < MLO_N_LCL_OUT_MAPS; ++k)
}

/*********************************************************************************************************
// brw algorithm with stride 4
// idea:
// process 4x4 micro-tile
// loop with duble buffering
// read 3x3 input micro-tile into registers
// 11x11 filter into LDS


**********************************************************************************************************/

__attribute__((reqd_work_group_size(MLO_GRP_SZ0, MLO_GRP_SZ1, MLO_GRP_SZ2))) __kernel void
MIOpenCvBwd11x11(const __global _FLOAT* __restrict bot,
                 const __global _FLOAT* __restrict weights,
#if MLO_CONV_BIAS == 1
                 const __global _FLOAT* __restrict bias,
#endif
                 __global _FLOAT* __restrict top,
                 UNUSED _FLOAT padding_val)
{
    // double buffering
    __local _FLOAT lcl_mem[MLO_LCL_BWD_MEM_SZ];

    uint lcl_wei_write_off = 0;
    uint lcl_wei_read_off  = 0;

#undef MLO_ACCUM_SZ
#define MLO_ACCUM_SZ (MLO_OUT_PIX_TILE1 * MLO_OUT_PIX_TILE0 * MLO_N_LCL_OUT_MAPS)
    _FLOAT_ACCUM pvt_accum[MLO_ACCUM_SZ];

    for(uint i = 0; i < MLO_ACCUM_SZ; ++i)
    {
        pvt_accum[i] = CVT_FLOAT2ACCUM(0);
    }

    uint lcl_id = get_local_id(0);

    uint gbl_id = get_global_id(0); // id of the 4x4 micro-tile inside the output buffer

    uint tile_y = (gbl_id / MLO_N_TILES0);
    uint tile_x = (gbl_id % MLO_N_TILES0);

    uint k_idx = get_global_id(1) * MLO_N_LCL_OUT_MAPS; // output idx

    uint b_idx = get_global_id(2); // batch

    // prefetch input map
    _FLOAT proc_dat[MLO_IN_PIX_TILE1][MLO_IN_PIX_TILE0];

    uint gbl_in_off = b_idx * MLO_IN_BATCH_STRIDE;

    int map_out_y = (int)tile_y * MLO_OUT_PIX_TILE1 - MLO_FILTER_PAD1;

    int map_in_y = (map_out_y + MLO_OUT_PIX_TILE1 - 1) / MLO_FILTER_STRIDE1;

    int map_out_x = (int)tile_x * MLO_OUT_PIX_TILE0 - MLO_FILTER_PAD0;

    int map_in_x = (map_out_x + MLO_OUT_PIX_TILE0 - 1) / MLO_FILTER_STRIDE0;

    // stupid compiler
    uint out_of_range_y[MLO_IN_PIX_TILE1];
    uint out_of_range_x[MLO_IN_PIX_TILE0];
    _FLOAT mask_out_of_range[MLO_IN_PIX_TILE1 * MLO_IN_PIX_TILE0];

    uint gbl_in_offs[MLO_IN_PIX_TILE1][MLO_IN_PIX_TILE0];

    for(int j = MLO_IN_PIX_TILE1 - 1; j >= 0; --j)
    {
        out_of_range_y[j] = ((map_in_y + (j - MLO_IN_PIX_TILE1 + 1)) >= MLO_IN_HEIGHT ||
                             (map_in_y + (j - MLO_IN_PIX_TILE1 + 1)) < 0)
                                ? 0
                                : (uint)(-1);

        for(int i = MLO_IN_PIX_TILE0 - 1; i >= 0; --i)
        {
            out_of_range_x[i] = ((map_in_x + (i - MLO_IN_PIX_TILE0 + 1)) >= MLO_IN_WIDTH ||
                                 (map_in_x + (i - MLO_IN_PIX_TILE0 + 1)) < 0)
                                    ? 0
                                    : (uint)(-1);
            gbl_in_offs[j][i] = (((map_in_y + (j - MLO_IN_PIX_TILE1 + 1)) * MLO_IN_STRIDE +
                                  (map_in_x + (i - MLO_IN_PIX_TILE0 + 1))) &
                                 (out_of_range_x[i] & out_of_range_y[j]));

            mask_out_of_range[j * MLO_IN_PIX_TILE0 + i] =
                (out_of_range_x[i] & out_of_range_y[j]) ? 1 : 0;
        }
    }

#if defined(__AMDGCN__)
    uint grp_gbl_id = get_group_id(0) * MLO_GRP_SZ;
    uint grp_tile_y = (grp_gbl_id / MLO_N_TILES0);
    // adjust col pos to 0 to read from the beginning of the scan for easyie mapping
    uint grp_tile_x = (MLO_N_TILES0 < MLO_GRP_SZ) ? 0 : (grp_gbl_id % MLO_N_TILES0);

    int grp_out_y = (int)grp_tile_y * MLO_OUT_PIX_TILE1 - MLO_FILTER_PAD1;
    int grp_out_x = (int)grp_tile_x * MLO_OUT_PIX_TILE0 - MLO_FILTER_PAD0;

    int grp_in_y = (grp_out_y + MLO_OUT_PIX_TILE1 - 1) / MLO_FILTER_STRIDE1 - MLO_IN_PIX_TILE1 + 1;
    int grp_in_x = (grp_out_x + MLO_OUT_PIX_TILE0 - 1) / MLO_FILTER_STRIDE0 - MLO_IN_PIX_TILE0 + 1;

    uint lcl_in_y = (uint)((tile_y - grp_tile_y) * MLO_OUT_PIX_TILE1) / MLO_FILTER_STRIDE1;

    uint lcl_in_x = (uint)((tile_x - grp_tile_x) * MLO_OUT_PIX_TILE0) / MLO_FILTER_STRIDE0;
#endif

    uint gbl_wei_off = k_idx * MLO_WEI_CHANNEL_STRIDE;

    //#pragma unroll 2
    for(int c = 0; c < MLO_N_INPUTS;
        ++c, gbl_in_off += MLO_IN_CHANNEL_STRIDE, gbl_wei_off += MLO_WEI_BATCH_STRIDE)
    {

// move data in
#if defined(__AMDGCN__)
        MoveDataIn(proc_dat, lcl_mem, bot, gbl_in_off, grp_in_y, grp_in_x, lcl_in_y, lcl_in_x);
#endif
        // move next weights in

        MoveWeightsIn(lcl_mem, lcl_wei_write_off, weights, gbl_wei_off, lcl_id);

// move data in
#if !defined(__AMDGCN__)
        MoveDataIn(proc_dat, bot, gbl_in_off, gbl_in_offs, mask_out_of_range);
#endif
        // convolve

        Convolve(pvt_accum,
                 proc_dat,
                 lcl_mem,
                 lcl_wei_read_off
#if DBG_PRINTF == 1
                 ,
                 map_out_y,
                 map_out_x
#endif
                 );

    } // for (int c = 0; c < MLO_N_INPUTS; ++c, gbl_in_off += MLO_IN_CHANNEL_STRIDE, gbl_wei_off +=
      // MLO_WEI_BATCH_STRIDE)

    // write out
    for(uint k = 0; k < MLO_N_LCL_OUT_MAPS; ++k)
    {
        // write out
        // inputs are outputs
        int out_off = b_idx * MLO_OUT_BATCH_STRIDE + (k_idx + k) * MLO_OUT_CHANNEL_STRIDE +
                      map_out_y * MLO_OUT_STRIDE + map_out_x;
        __global _FLOAT* top_p = &top[out_off];
        for(int j = 0; j < MLO_OUT_PIX_TILE1; ++j)
        {
            for(int i = 0; i < MLO_OUT_PIX_TILE0; ++i)
            {
                if((k_idx + k) < MLO_N_OUTPUTS && map_out_y + j < MLO_OUT_HEIGHT &&
                   map_out_y + j >= 0 && map_out_x + i < MLO_OUT_WIDTH && map_out_x + i >= 0)
                {
                    top_p[j * MLO_OUT_STRIDE + i] = CVT_ACCUM2FLOAT(
                        pvt_accum[(k * MLO_OUT_PIX_TILE1 + j) * MLO_OUT_PIX_TILE0 + i]);
                }
            }
        }
    }
}

#endif // MLO_DIR_FORWARD == 1
     /*******************************************************************************
 *
 * MIT License
 *
 * Copyright (c) 2017 Advanced Micro Devices, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 *******************************************************************************/

#define fptype float

#define fvect2 float2

#define C3QA 0.50000000000000000000000000000000f
#define C3QB 0.86602540378443864676372317075294f

void FwdRad3B1(float2* R0, float2* R1, float2* R2)
{

    float TR0, TI0, TR1, TI1, TR2, TI2;

    TR0 = (*R0).x + (*R1).x + (*R2).x;
    TR1 = ((*R0).x - C3QA * ((*R1).x + (*R2).x)) + C3QB * ((*R1).y - (*R2).y);
    TR2 = ((*R0).x - C3QA * ((*R1).x + (*R2).x)) - C3QB * ((*R1).y - (*R2).y);

    TI0 = (*R0).y + (*R1).y + (*R2).y;
    TI1 = ((*R0).y - C3QA * ((*R1).y + (*R2).y)) - C3QB * ((*R1).x - (*R2).x);
    TI2 = ((*R0).y - C3QA * ((*R1).y + (*R2).y)) + C3QB * ((*R1).x - (*R2).x);

    ((*R0).x) = TR0;
    ((*R0).y) = TI0;
    ((*R1).x) = TR1;
    ((*R1).y) = TI1;
    ((*R2).x) = TR2;
    ((*R2).y) = TI2;
}

void InvRad3B1(float2* R0, float2* R1, float2* R2)
{

    float TR0, TI0, TR1, TI1, TR2, TI2;

    TR0 = (*R0).x + (*R1).x + (*R2).x;
    TR1 = ((*R0).x - C3QA * ((*R1).x + (*R2).x)) - C3QB * ((*R1).y - (*R2).y);
    TR2 = ((*R0).x - C3QA * ((*R1).x + (*R2).x)) + C3QB * ((*R1).y - (*R2).y);

    TI0 = (*R0).y + (*R1).y + (*R2).y;
    TI1 = ((*R0).y - C3QA * ((*R1).y + (*R2).y)) + C3QB * ((*R1).x - (*R2).x);
    TI2 = ((*R0).y - C3QA * ((*R1).y + (*R2).y)) - C3QB * ((*R1).x - (*R2).x);

    ((*R0).x) = TR0;
    ((*R0).y) = TI0;
    ((*R1).x) = TR1;
    ((*R1).y) = TI1;
    ((*R2).x) = TR2;
    ((*R2).y) = TI2;
}

void FwdRad6B1(float2* R0, float2* R1, float2* R2, float2* R3, float2* R4, float2* R5)
{

    float TR0, TI0, TR1, TI1, TR2, TI2, TR3, TI3, TR4, TI4, TR5, TI5;

    TR0 = (*R0).x + (*R2).x + (*R4).x;
    TR2 = ((*R0).x - C3QA * ((*R2).x + (*R4).x)) + C3QB * ((*R2).y - (*R4).y);
    TR4 = ((*R0).x - C3QA * ((*R2).x + (*R4).x)) - C3QB * ((*R2).y - (*R4).y);

    TI0 = (*R0).y + (*R2).y + (*R4).y;
    TI2 = ((*R0).y - C3QA * ((*R2).y + (*R4).y)) - C3QB * ((*R2).x - (*R4).x);
    TI4 = ((*R0).y - C3QA * ((*R2).y + (*R4).y)) + C3QB * ((*R2).x - (*R4).x);

    TR1 = (*R1).x + (*R3).x + (*R5).x;
    TR3 = ((*R1).x - C3QA * ((*R3).x + (*R5).x)) + C3QB * ((*R3).y - (*R5).y);
    TR5 = ((*R1).x - C3QA * ((*R3).x + (*R5).x)) - C3QB * ((*R3).y - (*R5).y);

    TI1 = (*R1).y + (*R3).y + (*R5).y;
    TI3 = ((*R1).y - C3QA * ((*R3).y + (*R5).y)) - C3QB * ((*R3).x - (*R5).x);
    TI5 = ((*R1).y - C3QA * ((*R3).y + (*R5).y)) + C3QB * ((*R3).x - (*R5).x);

    (*R0).x = TR0 + TR1;
    (*R1).x = TR2 + (C3QA * TR3 + C3QB * TI3);
    (*R2).x = TR4 + (-C3QA * TR5 + C3QB * TI5);

    (*R0).y = TI0 + TI1;
    (*R1).y = TI2 + (-C3QB * TR3 + C3QA * TI3);
    (*R2).y = TI4 + (-C3QB * TR5 - C3QA * TI5);

    (*R3).x = TR0 - TR1;
    (*R4).x = TR2 - (C3QA * TR3 + C3QB * TI3);
    (*R5).x = TR4 - (-C3QA * TR5 + C3QB * TI5);

    (*R3).y = TI0 - TI1;
    (*R4).y = TI2 - (-C3QB * TR3 + C3QA * TI3);
    (*R5).y = TI4 - (-C3QB * TR5 - C3QA * TI5);
}

void InvRad6B1(float2* R0, float2* R1, float2* R2, float2* R3, float2* R4, float2* R5)
{

    float TR0, TI0, TR1, TI1, TR2, TI2, TR3, TI3, TR4, TI4, TR5, TI5;

    TR0 = (*R0).x + (*R2).x + (*R4).x;
    TR2 = ((*R0).x - C3QA * ((*R2).x + (*R4).x)) - C3QB * ((*R2).y - (*R4).y);
    TR4 = ((*R0).x - C3QA * ((*R2).x + (*R4).x)) + C3QB * ((*R2).y - (*R4).y);

    TI0 = (*R0).y + (*R2).y + (*R4).y;
    TI2 = ((*R0).y - C3QA * ((*R2).y + (*R4).y)) + C3QB * ((*R2).x - (*R4).x);
    TI4 = ((*R0).y - C3QA * ((*R2).y + (*R4).y)) - C3QB * ((*R2).x - (*R4).x);

    TR1 = (*R1).x + (*R3).x + (*R5).x;
    TR3 = ((*R1).x - C3QA * ((*R3).x + (*R5).x)) - C3QB * ((*R3).y - (*R5).y);
    TR5 = ((*R1).x - C3QA * ((*R3).x + (*R5).x)) + C3QB * ((*R3).y - (*R5).y);

    TI1 = (*R1).y + (*R3).y + (*R5).y;
    TI3 = ((*R1).y - C3QA * ((*R3).y + (*R5).y)) + C3QB * ((*R3