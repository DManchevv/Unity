mov_b64 s[24:25], vcc
  v_cmp_gt_i32 vcc, v3, v11
  s_and_b64 s[24:25], s[24:25], vcc
  v_cmp_le_i32 vcc, 0, v12
  s_and_b64 s[24:25], s[24:25], vcc
  v_cmp_gt_i32 vcc, v4, v12
  s_and_b64 s[24:25], s[24:25], vcc
  v_cmp_gt_i32 vcc, 13, v10
  s_mov_b64 s[6:7], vcc
  v_cmp_le_i32 vcc, -1, v13
  s_and_b64 s[26:27], s[6:7], vcc
  v_cmp_gt_i32 vcc, v3, v13
  s_and_b64 s[26:27], s[26:27], vcc
  v_cmp_le_i32 vcc, 0, v14
  s_and_b64 s[26:27], s[26:27], vcc
  v_cmp_gt_i32 vcc, v4, v14
  s_and_b64 s[26:27], s[26:27], vcc
  v_mov_b32 v3, 223
  v_cmp_eq_i32 vcc, -1, v11
  s_and_b64 s[28:29], s[24:25], vcc
  v_cmp_eq_i32 vcc, v3, v11
  s_and_b64 s[32:33], s[24:25], vcc
  v_cmp_eq_i32 vcc, -1, v13
  s_and_b64 s[30:31], s[26:27], vcc
  v_cmp_eq_i32 vcc, v3, v13
  s_and_b64 s[34:35], s[26:27], vcc
  s_waitcnt lgkmcnt(0)
  s_add_u32 s100, s100, s5
  s_addc_u32 s101, s101, 0
  s_add_u32 s16, s16, s23
  s_addc_u32 s17, s17, 0
  s_mul_i32 s8, s4, 602112
  s_add_u32 s12, s12, s8
  s_addc_u32 s13, s13, 0
  v_mov_b32 v8, 0
  v_mov_b32 v9, 0
  v_mov_b32 v10, 0
  v_mov_b32 v11, 0
  v_mov_b32 v12, 0
  v_mov_b32 v13, 0
  v_mov_b32 v14, 0
  v_mov_b32 v15, 0
  s_movk_i32 s21, 3
  v_writelane_b32 v22, s6, 0
  v_writelane_b32 v22, s7, 1
  v_writelane_b32 v22, s21, 2
  v_writelane_b32 v22, s12, 6
  v_writelane_b32 v22, s13, 7
  v_writelane_b32 v22, s20, 3
  v_writelane_b32 v22, s22, 4
  v_writelane_b32 v22, s16, 10
  v_writelane_b32 v22, s17, 11
  v_writelane_b32 v22, s36, 5
  v_writelane_b32 v22, s24, 14
  v_writelane_b32 v22, s25, 15
  v_writelane_b32 v22, s26, 16
  v_writelane_b32 v22, s27, 17
  v_writelane_b32 v22, s28, 18
  v_writelane_b32 v22, s29, 19
  v_writelane_b32 v22, s30, 22
  v_writelane_b32 v22, s31, 23
  v_writelane_b32 v22, s32, 20
  v_writelane_b32 v22, s33, 21
  v_writelane_b32 v22, s34, 24
  v_writelane_b32 v22, s35, 25
loop_channel:
  v_readlane_b32 s24, v22, 14
  v_readlane_b32 s25, v22, 15
  v_readlane_b32 s26, v22, 16
  v_readlane_b32 s27, v22, 17
  v_readlane_b32 s6, v22, 0
  v_readlane_b32 s7, v22, 1
  v_readlane_b32 s12, v22, 6
  v_readlane_b32 s13, v22, 7
  s_mov_b32 s14, 602112
  s_mov_b32 s15, 0x00020000
  v_readlane_b32 s36, v22, 5
  v_mov_b32 v0, s36
  v_mov_b32 v1, s36
  v_mov_b32 v2, s36
  v_mov_b32 v3, s36
  s_mov_b64 exec, s[24:25]
  buffer_load_dwordx2 v[0:1], v16, s[12:15], 0 offen offset:0
  s_mov_b64 exec, s[26:27]
  buffer_load_dwordx2 v[2:3], v17, s[12:15], 0 offen offset:0
  s_mov_b64 exec, -1
  v_mov_b32 v4, 200704
 _v_add_co_u32 v16, vcc, v16, v4
 _v_add_co_u32 v17, vcc, v17, v4
  v_readlane_b32 s28, v22, 18
  v_readlane_b32 s29, v22, 19
  v_readlane_b32 s32, v22, 20
  v_readlane_b32 s33, v22, 21
  v_readlane_b32 s30, v22, 22
  v_readlane_b32 s31, v22, 23
  v_readlane_b32 s34, v22, 24
  v_readlane_b32 s35, v22, 25
  s_waitcnt lgkmcnt(0) vmcnt(0)
  s_mov_b64 exec, s[28:29]
  v_mov_b32 v1, v0
  v_mov_b32 v0, s36
  s_mov_b64 exec, s[32:33]
  v_mov_b32 v1, s36
  s_mov_b64 exec, s[30:31]
  v_mov_b32 v3, v2
  v_mov_b32 v2, s36
  s_mov_b64 exec, s[34:35]
  v_mov_b32 v3, s36
  s_mov_b64 exec, -1
  s_barrier
  ds_write_b64 v18, v[0:1] offset:0
  s_mov_b64 exec, s[6:7]
  ds_write_b64 v19, v[2:3] offset:0
  s_mov_b64 exec, -1
  s_waitcnt lgkmcnt(0)
  s_barrier
  s_load_dwordx16 s[0:15], s[100:101], 0
  s_load_dwordx16 s[16:31], s[100:101], 64
  s_load_dwordx16 s[32:47], s[100:101], 128
  s_load_dword s96, s[100:101], 192
  s_add_u32 s100, s100, 588
  s_addc_u32 s101, s101, 0
  s_load_dwordx16 s[48:63], s[100:101], 0
  s_load_dwordx16 s[64:79], s[100:101], 64
  s_load_dwordx16 s[80:95], s[100:101], 128
  s_load_dword s97, s[100:101], 192
  s_add_u32 s100, s100, 4294966904
  s_addc_u32 s101, s101, -1
  s_waitcnt lgkmcnt(0) vmcnt(0)
  ds_read_b64 v[0:1], v20 offset:0
  ds_read_b64 v[2:3], v20 offset:8
  ds_read_b64 v[4:5], v20 offset:16
  ds_read_b32 v6, v20 offset:24
  s_waitcnt lgkmcnt(2)
  v_mac_f32 v8, v0, s0
  v_mac_f32 v8, v1, s1
  v_mac_f32 v8, v2, s2
  v_mac_f32 v8, v3, s3
  v_mac_f32 v12, v0, s48
  v_mac_f32 v12, v1, s49
  v_mac_f32 v12, v2, s50
  v_mac_f32 v12, v3, s51
  ds_read_b64 v[0:1], v20 offset:536
  ds_read_b64 v[2:3], v20 offset:544
  s_waitcnt lgkmcnt(2)
  v_mac_f32 v8, v4, s4
  v_mac_f32 v8, v5, s5
  v_mac_f32 v8, v6, s6
  v_mac_f32 v12, v4, s52
  v_mac_f32 v12, v5, s53
  v_mac_f32 v12, v6, s54
  ds_read_b64 v[4:5], v20 offset:552
  ds_read_b32 v6, v20 offset:560
  s_waitcnt lgkmcnt(2)
  v_mac_f32 v8, v0, s7
  v_mac_f32 v8, v1, s8
  v_mac_f32 v8, v2, s9
  v_mac_f32 v8, v3, s10
  v_mac_f32 v12, v0, s55
  v_mac_f32 v12, v1, s56
  v_mac_f32 v12, v2, s57
  v_mac_f32 v12, v3, s58
  ds_read_b64 v[0:1], v20 offset:1072
  ds_read_b64 v[2:3], v20 offset:1080
  s_waitcnt lgkmcnt(2)
  v_mac_f32 v8, v4, s11
  v_mac_f32 v8, v5, s12
  v_mac_f32 v8, v6, s13
  v_mac_f32 v12, v4, s59
  v_mac_f32 v12, v5, s60
  v_mac_f32 v12, v6, s61
  ds_read_b64 v[4:5], v20 offset:1088
  ds_read_b32 v6, v20 offset:1096
  s_waitcnt lgkmcnt(2)
  v_mac_f32 v8, v0, s14
  v_mac_f32 v8, v1, s15
  v_mac_f32 v8, v2, s16
  v_mac_f32 v8, v3, s17
  v_mac_f32 v9, v0, s0
  v_mac_f32 v9, v1, s1
  v_mac_f32 v9, v2, s2
  v_mac_f32 v9, v3, s3
  v_mac_f32 v12, v0, s62
  v_mac_f32 v12, v1, s63
  v_mac_f32 v12, v2, s64
  v_mac_f32 v12, v3, s65
  v_mac_f32 v13, v0, s48
  v_mac_f32 v13, v1, s49
  v_mac_f32 v13, v2, s50
  v_mac_f32 v13, v3, s51
  ds_read_b64 v[0:1], v20 offset:1608
  ds_read_b64 v[2:3], v20 offset:1616
  s_waitcnt lgkmcnt(2)
  v_mac_f32 v8, v4, s18
  v_mac_f32 v8, v5, s19
  v_mac_f32 v8, v6, s20
  v_mac_f32 v9, v4, s4
  v_mac_f32 v9, v5, s5
  v_mac_f32 v9, v6, s6
  v_mac_f32 v12, v4, s66
  v_mac_f32 v12, v5, s67
  v_mac_f32 v12, v6, s68
  v_mac_f32 v13, v4, s52
  v_mac_f32 v13, v5, s53
  v_mac_f32 v13, v6, s54
  ds_read_b64 v[4:5], v20 offset:1624
  ds_read_b32 v6, v20 offset:1632
  s_waitcnt lgkmcnt(2)
  v_mac_f32 v8, v0, s21
  v_mac_f32 v8, v1, s22
  v_mac_f32 v8, v2, s23
  v_mac_f32 v8, v3, s24
  v_mac_f32 v9, v0, s7
  v_mac_f32 v9, v1, s8
  v_mac_f32 v9, v2, s9
  v_mac_f32 v9, v3, s10
  v_mac_f32 v12, v0, s69
  v_mac_f32 v12, v1, s70
  v_mac_f32 v12, v2, s71
  v_mac_f32 v12, v3, s72
  v_mac_f32 v13, v0, s55
  v_mac_f32 v13, v1, s56
  v_mac_f32 v13, v2, s57
  v_mac_f32 v13, v3, s58
  ds_read_b64 v[0:1], v20 offset:2144
  ds_read_b64 v[2:3], v20 offset:2152
  s_waitcnt lgkmcnt(2)
  v_mac_f32 v8, v4, s25
  v_mac_f32 v8, v5, s26
  v_mac_f32 v8, v6, s27
  v_mac_f32 v9, v4, s11
  v_mac_f32 v9, v5, s12
  v_mac_f32 v9, v6, s13
  v_mac_f32 v12, v4, s73
  v_mac_f32 v12, v5, s74
  v_mac_f32 v12, v6, s75
  v_mac_f32 v13, v4, s59
  v_mac_f32 v13, v5, s60
  v_mac_f32 v13, v6, s61
  ds_read_b64 v[4:5], v20 offset:2160
  ds_read_b32 v6, v20 offset:2168
  s_waitcnt lgkmcnt(2)
  v_mac_f32 v8, v0, s28
  v_mac_f32 v8, v1, s29
  v_mac_f32 v8, v2, s30
  v_mac_f32 v8, v3, s31
  v_mac_f32 v9, v0, s14
  v_mac_f32 v9, v1, s15
  v_mac_f32 v9, v2, s16
  v_mac_f32 v9, v3, s17
  v_mac_f32 v10, v0, s0
  v_mac_f32 v10, v1, s1
  v_mac_f32 v10, v2, s2
  v_mac_f32 v10, v3, s3
  v_mac_f32 v12, v0, s76
  v_mac_f32 v12, v1, s77
  v_mac_f32 v12, v2, s78
  v_mac_f32 v12, v3, s79
  v_mac_f32 v13, v0, s62
  v_mac_f32 v13, v1, s63
  v_mac_f32 v13, v2, s64
  v_mac_f32 v13, v3, s65
  v_mac_f32 v14, v0, s48
  v_mac_f32 v14, v1, s49
  v_mac_f32 v14, v2, s50
  v_mac_f32 v14, v3, s51
  ds_read_b64 v[0:1], v20 offset:2680
  ds_read_b64 v[2:3], v20 offset:2688
  s_waitcnt lgkmcnt(2)
  v_mac_f32 v8, v4, s32
  v_mac_f32 v8, v5, s33
  v_mac_f32 v8, v6, s34
  v_mac_f32 v9, v4, s18
  v_mac_f32 v9, v5, s19
  v_mac_f32 v9, v6, s20
  v_mac_f32 v10, v4, s4
  v_mac_f32 v10, v5, s5
  v_mac_f32 v10, v6, s6
  v_mac_f32 v12, v4, s80
  v_mac_f32 v12, v5, s81
  v_mac_f32 v12, v6, s82
  v_mac_f32 v13, v4, s66
  v_mac_f32 v13, v5, s67
  v_mac_f32 v13, v6, s68
  v_mac_f32 v14, v4, s52
  v_mac_f32 v14, v5, s53
  v_mac_f32 v14, v6, s54
  ds_read_b64 v[4:5], v20 offset:2696
  ds_read_b32 v6, v20 offset:2704
  s_waitcnt lgkmcnt(2)
  v_mac_f32 v8, v0, s35
  v_mac_f32 v8, v1, s36
  v_mac_f32 v8, v2, s37
  v_mac_f32 v8, v3, s38
  v_mac_f32 v9, v0, s21
  v_mac_f32 v9, v1, s22
  v_mac_f32 v9, v2, s23
  v_mac_f32 v9, v3, s24
  v_mac_f32 v10, v0, s7
  v_mac_f32 v10, v1, s8
  v_mac_f32 v10, v2, s9
  v_mac_f32 v10, v3, s10
  v_mac_f32 v12, v0, s83
  v_mac_f32 v12, v1, s84
  v_mac_f32 v12, v2, s85
  v_mac_f32 v12, v3, s86
  v_mac_f32 v13, v0, s69
  v_mac_f32 v13, v1, s70
  v_mac_f32 v13, v2, s71
  v_mac_f32 v13, v3, s72
  v_mac_f32 v14, v0, s55
  v_mac_f32 v14, v1, s56
  v_mac_f32 v14, v2, s57
  v_mac_f32 v14, v3, s58
  ds_read_b64 v[0:1], v20 offset:3216
  ds_read_b64 v[2:3], v20 offset:3224
  s_waitcnt lgkmcnt(2)
  v_mac_f32 v8, v4, s39
  v_mac_f32 v8, v5, s40
  v_mac_f32 v8, v6, s41
  v_mac_f32 v9, v4, s25
  v_mac_f32 v9, v5, s26
  v_mac_f32 v9, v6, s27
  v_mac_f32 v10, v4, s11
  v_mac_f32 v10, v5, s12
  v_mac_f32 v10, v6, s13
  v_mac_f32 v12, v4, s87
  v_mac_f32 v12, v5, s88
  v_mac_f32 v12, v6, s89
  v_mac_f32 v13, v4, s73
  v_mac_f32 v13, v5, s74
  v_mac_f32 v13, v6, s75
  v_mac_f32 v14, v4, s59
  v_mac_f32 v14, v5, s60
  v_mac_f32 v14, v6, s61
  ds_read_b64 v[4:5], v20 offset:3232
  ds_read_b32 v6, v20 offset:3240
  s_waitcnt lgkmcnt(2)
  v_mac_f32 v8, v0, s42
  v_mac_f32 v8, v1, s43
  v_mac_f32 v8, v2, s44
  v_mac_f32 v8, v3, s45
  v_mac_f32 v9, v0, s28
  v_mac_f32 v9, v1, s29
  v_mac_f32 v9, v2, s30
  v_mac_f32 v9, v3, s31
  v_mac_f32 v10, v0, s14
  v_mac_f32 v10, v1, s15
  v_mac_f32 v10, v2, s16
  v_mac_f32 v10, v3, s17
  v_mac_f32 v11, v0, s0
  v_mac_f32 v11, v1, s1
  v_mac_f32 v11, v2, s2
  v_mac_f32 v11, v3, s3
  v_mac_f32 v12, v0, s90
  v_mac_f32 v12, v1, s91
  v_mac_f32 v12, v2, s92
  v_mac_f32 v12, v3, s93
  v_mac_f32 v13, v0, s76
  v_mac_f32 v13, v1, s77
  v_mac_f32 v13, v2, s78
  v_mac_f32 v13, v3, s79
  v_mac_f32 v14, v0, s62
  v_mac_f32 v14, v1, s63
  v_mac_f32 v14, v2, s64
  v_mac_f32 v14, v3, s65
  v_mac_f32 v15, v0, s48
  v_mac_f32 v15, v1, s49
  v_mac_f32 v15, v2, s50
  v_mac_f32 v15, v3, s51
  ds_read_b64 v[0:1], v20 offset:3752
  ds_read_b64 v[2:3], v20 offset:3760
  s_waitcnt lgkmcnt(2)
  v_mac_f32 v8, v4, s46
  v_mac_f32 v8, v5, s47
  v_mac_f32 v8, v6, s96
  v_mac_f32 v9, v4, s32
  v_mac_f32 v9, v5, s33
  v_mac_f32 v9, v6, s34
  v_mac_f32 v10, v4, s18
  v_mac_f32 v10, v5, s19
  v_mac_f32 v10, v6, s20
  v_mac_f32 v11, v4, s4
  v_mac_f32 v11, v5, s5
  v_mac_f32 v11, v6, s6
  v_mac_f32 v12, v4, s94
  v_mac_f32 v12, v5, s95
  v_mac_f32 v12, v6, s97
  v_mac_f32 v13, v4, s80
  v_mac_f32 v13, v5, s81
  v_mac_f32 v13, v6, s82
  v_mac_f32 v14, v4, s66
  v_mac_f32 v14, v5, s67
  v_mac_f32 v14, v6, s68
  v_mac_f32 v15, v4, s52
  v_mac_f32 v15, v5, s53
  v_mac_f32 v15, v6, s54
  ds_read_b64 v[4:5], v20 offset:3768
  ds_read_b32 v6, v20 offset:3776
  s_waitcnt lgkmcnt(2)
  v_mac_f32 v9, v0, s35
  v_mac_f32 v9, v1, s36
  v_mac_f32 v9, v2, s37
  v_mac_f32 v9, v3, s38
  v_mac_f32 v10, v0, s21
  v_mac_f32 v10, v1, s22
  v_mac_f32 v10, v2, s23
  v_mac_f32 v10, v3, s24
  v_mac_f32 v11, v0, s7
  v_mac_f32 v11, v1, s8
  v_mac_f32 v11, v2, s9
  v_mac_f32 v11, v3, s10
  v_mac_f32 v13, v0, s83
  v_mac_f32 v13, v1, s84
  v_mac_f32 v13, v2, s85
  v_mac_f32 v13, v3, s86
  v_mac_f32 v14, v0, s69
  v_mac_f32 v14, v1, s70
  v_mac_f32 v14, v2, s71
  v_mac_f32 v14, v3, s72
  v_mac_f32 v15, v0, s55
  v_mac_f32 v15, v1, s56
  v_mac_f32 v15, v2, s57
  v_mac_f32 v15, v3, s58
  ds_read_b64 v[0:1], v20 offset:4288
  ds_read_b64 v[2:3], v20 offset:4296
  s_waitcnt lgkmcnt(2)
  v_mac_f32 v9, v4, s39
  v_mac_f32 v9, v5, s40
  v_mac_f32 v9, v6, s41
  v_mac_f32 v10, v4, s25
  v_mac_f32 v10, v5, s26
  v_mac_f32 v10, v6, s27
  v_mac_f32 v11, v4, s11
  v_mac_f32 v11, v5, s12
  v_mac_f32 v11, v6, s13
  v_mac_f32 v13, v4, s87
  v_mac_f32 v13, v5, s88
  v_mac_f32 v13, v6, s89
  v_mac_f32 v14, v4, s73
  v_mac_f32 v14, v5, s74
  v_mac_f32 v14, v6, s75
  v_mac_f32 v15, v4, s59
  v_mac_f32 v15, v5, s60
  v_mac_f32 v15, v6, s61
  ds_read_b64 v[4:5], v20 offset:4304
  ds_read_b32 v6, v20 offset:4312
  s_waitcnt lgkmcnt(2)
  v_mac_f32 v9, v0, s42
  v_mac_f32 v9, v1, s43
  v_mac_f32 v9, v2, s44
  v_mac_f32 v9, v3, s45
  v_mac_f32 v10, v0, s28
  v_mac_f32 v10, v1, s29
  v_mac_f32 v10, v2, s30
  v_mac_f32 v10, v3, s31
  v_mac_f32 v11, v0, s14
  v_mac_f32 v11, v1, s15
  v_mac_f32 v11, v2, s16
  v_mac_f32 v11, v3, s17
  v_mac_f32 v13, v0, s90
  v_mac_f32 v13, v1, s91
  v_mac_f32 v13, v2, s92
  v_mac_f32 v13, v3, s93
  v_mac_f32 v14, v0, s76
  v_mac_f32 v14, v1, s77
  v_mac_f32 v14, v2, s78
  v_mac_f32 v14, v3, s79
  v_mac_f32 v15, v0, s62
  v_mac_f32 v15, v1, s63
  v_mac_f32 v15, v2, s64
  v_mac_f32 v15, v3, s65
  ds_read_b64 v[0:1], v20 offset:4824
  ds_read_b64 v[2:3], v20 offset:4832
  s_waitcnt lgkmcnt(2)
  v_mac_f32 v9, v4, s46
  v_mac_f32 v9, v5, s47
  v_mac_f32 v9, v6, s96
  v_mac_f32 v10, v4, s32
  v_mac_f32 v10, v5, s33
  v_mac_f32 v10, v6, s34
  v_mac_f32 v11, v4, s18
  v_mac_f32 v11, v5, s19
  v_mac_f32 v11, v6, s20
  v_mac_f32 v13, v4, s94
  v_mac_f32 v13, v5, s95
  v_mac_f32 v13, v6, s97
  v_mac_f32 v14, v4, s80
  v_mac_f32 v14, v5, s81
  v_mac_f32 v14, v6, s82
  v_mac_f32 v15, v4, s66
  v_mac_f32 v15, v5, s67
  v_mac_f32 v15, v6, s68
  ds_read_b64 v[4:5], v20 offset:4840
  ds_read_b32 v6, v20 offset:4848
  s_waitcnt lgkmcnt(2)
  v_mac_f32 v10, v0, s35
  v_mac_f32 v10, v1, s36
  v_mac_f32 v10, v2, s37
  v_mac_f32 v10, v3, s38
  v_mac_f32 v11, v0, s21
  v_mac_f32 v11, v1, s22
  v_mac_f32 v11, v2, s23
  v_mac_f32 v11, v3, s24
  v_mac_f32 v14, v0, s83
  v_mac_f32 v14, v1, s84
  v_mac_f32 v14, v2, s85
  v_mac_f32 v14, v3, s86
  v_mac_f32 v15, v0, s69
  v_mac_f32 v15, v1, s70
  v_mac_f32 v15, v2, s71
  v_mac_f32 v15, v3, s72
  ds_read_b64 v[0:1], v20 offset:5360
  ds_read_b64 v[2:3], v20 offset:5368
  s_waitcnt lgkmcnt(2)
  v_mac_f32 v10, v4, s39
  v_mac_f32 v10, v5, s40
  v_mac_f32 v10, v6, s41
  v_mac_f32 v11, v4, s25
  v_mac_f32 v11, v5, s26
  v_mac_f32 v11, v6, s27
  v_mac_f32 v14, v4, s87
  v_mac_f32 v14, v5, s88
  v_mac_f32 v14, v6, s89
  v_mac_f32 v15, v4, s73
  v_mac_f32 v15, v5, s74
  v_mac_f32 v15, v6, s75
  ds_read_b64 v[4:5], v20 offset:5376
  ds_read_b32 v6, v20 offset:5384
  s_waitcnt lgkmcnt(2)
  v_mac_f32 v10, v0, s42
  v_mac_f32 v10, v1, s43
  v_mac_f32 v10, v2, s44
  v_mac_f32 v10, v3, s45
  v_mac_f32 v11, v0, s28
  v_mac_f32 v11, v1, s29
  v_mac_f32 v11, v2, s30
  v_mac_f32 v11, v3, s31
  v_mac_f32 v14, v0, s90
  v_mac_f32 v14, v1, s91
  v_mac_f32 v14, v2, s92
  v_mac_f32 v14, v3, s93
  v_mac_f32 v15, v0, s76
  v_mac_f32 v15, v1, s77
  v_mac_f32 v15, v2, s78
  v_mac_f32 v15, v3, s79
  ds_read_b64 v[0:1], v20 offset:5896
  ds_read_b64 v[2:3], v20 offset:5904
  s_waitcnt lgkmcnt(2)
  v_mac_f32 v10, v4, s46
  v_mac_f32 v10, v5, s47
  v_mac_f32 v10, v6, s96
  v_mac_f32 v11, v4, s32
  v_mac_f32 v11, v5, s33
  v_mac_f32 v11, v6, s34
  v_mac_f32 v14, v4, s94
  v_mac_f32 v14, v5, s95
  v_mac_f32 v14, v6, s97
  v_mac_f32 v15, v4, s80
  v_mac_f32 v15, v5, s81
  v_mac_f32 v15, v6, s82
  ds_read_b64 v[4:5], v20 offset:5912
  ds_read_b32 v6, v20 offset:5920
  s_waitcnt lgkmcnt(2)
  v_mac_f32 v11, v0, s35
  v_mac_f32 v11, v1, s36
  v_mac_f32 v11, v2, s37
  v_mac_f32 v11, v3, s38
  v_mac_f32 v15, v0, s83
  v_mac_f32 v15, v1, s84
  v_mac_f32 v15, v2, s85
  v_mac_f32 v15, v3, s86
  ds_read_b64 v[0:1], v20 offset:6432
  ds_read_b64 v[2:3], v20 offset:6440
  s_waitcnt lgkmcnt(2)
  v_mac_f32 v11, v4, s39
  v_mac_f32 v11, v5, s40
  v_mac_f32 v11, v6, s41
  v_mac_f32 v15, v4, s87
  v_mac_f32 v15, v5, s88
  v_mac_f32 v15, v6, s89
  ds_read_b64 v[4:5], v20 offset:6448
  ds_read_b32 v6, v20 offset:6456
  s_waitcnt lgkmcnt(1)
  v_mac_f32 v11, v0, s42
  v_mac_f32 v11, v1, s43
  v_mac_f32 v11, v2, s44
  v_mac_f32 v11, v3, s45
  v_mac_f32 v11, v4, s46
  v_mac_f32 v11, v5, s47
  v_mac_f32 v15, v0, s90
  v_mac_f32 v15, v1, s91
  v_mac_f32 v15, v2, s92
  v_mac_f32 v15, v3, s93
  v_mac_f32 v15, v4, s94
  v_mac_f32 v15, v5, s95
  s_waitcnt lgkmcnt(0)
  v_mac_f32 v11, v6, s96
  v_mac_f32 v15, v6, s97
  v_readlane_b32 s21, v22, 2
  s_sub_u32 s21, s21, 1
  v_writelane_b32 v22, s21, 2
  s_cmp_gt_u32 s21, 0
  s_cbranch_scc1 loop_channel
  v_readlane_b32 s20, v22, 3
  v_readlane_b32 s22, v22, 4
  v_readlane_b32 s16, v22, 10
  v_readlane_b32 s17, v22, 11
  s_mov_b32 s18, 100352
  s_mov_b32 s19, 0x00020000
  v_cmpx_gt_u32 vcc, 112, v21
  v_lshlrev_b32 v21, 2, v21
  s_mov_b32 s8, 0
  buffer_store_dword v8, v21, s[16:19], s8 offen offset:0
  s_mov_b32 s8, 448
  buffer_store_dword v9, v21, s[16:19], s8 offen offset:0
  s_mov_b32 s8, 896
  buffer_store_dword v10, v21, s[16:19], s8 offen offset:0
  s_mov_b32 s8, 1344
  buffer_store_dword v11, v21, s[16:19], s8 offen offset:0
  s_mov_b32 s8, 50176
  buffer_store_dword v12, v21, s[16:19], s8 offen offset:0
  s_mov_b32 s8, 50624
  buffer_store_dword v13, v21, s[16:19], s8 offen offset:0
  s_mov_b32 s8, 51072
  buffer_store_dword v14, v21, s[16:19], s8 offen offset:0
  s_mov_b32 s8, 51520
  buffer_store_dword v15, v21, s[16:19], s8 offen offset:0
  s_endpgm
.ifndef ROCM_METADATA_VERSION
.error "ROCM_METADATA_VERSION must be defined"
.endif
.if ROCM_METADATA_VERSION == 4
.amd_amdgpu_hsa_metadata
{ Version: [ 1, 0 ],
    Kernels:
    - {
        Name: gcnAsmConv7x7c3h224w224k64u2v2p3q3f1, SymbolName: 'gcnAsmConv7x7c3h224w224k64u2v2p3q3f1@kd', Language: OpenCL C, LanguageVersion: [ 1, 2 ],
        Attrs: { ReqdWorkGroupSize: [ 64, 8, 1 ] }
        CodeProps:
          { KernargSegmentSize: 32, GroupSegmentFixedSize: 7040, PrivateSegmentFixedSize: 0, KernargSegmentAlign: 8, WavefrontSize: 64, MaxFlatWorkGroupSize: 256 }
        Args:
        - { Size: 8, Align: 8, ValueKind: GlobalBuffer, ValueType: F32, TypeName: 'float*', Name: in,          AddrSpaceQual: Global, AccQual: Default, IsConst: true }
        - { Size: 8, Align: 8, ValueKind: GlobalBuffer, ValueType: F32, TypeName: 'float*', Name: weights,     AddrSpaceQual: Global, AccQual: Default, IsConst: true }
        - { Size: 8, Align: 8, ValueKind: GlobalBuffer, ValueType: F32, TypeName: 'float*', Name: out,         AddrSpaceQual: Global, AccQual: Default }
        - { Size: 4, Align: 4, ValueKind: ByValue,      ValueType: F32, TypeName:  float,   Name: padding_val,                        AccQual: Default }
      }
}
.end_amd_amdgpu_hsa_metadata
.else
  .error "Unsupported ROCM_METADATA_VERSION"
  .end
.endif
            /*******************************************************************************
 *
 * MIT License
 *
 * Copyright (c) 2017 Advanced Micro Devices, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 *******************************************************************************/
.hsa_code_object_version 2,1

.hsa_code_object_isa

.text
.amdgpu_hsa_kernel gcnAsmBNFwdTrainSpatial


/// \todo Better use common.inc. This requires more testing, so let's just copy macro here.
.macro static_assert fufufu
	.if !\fufufu
		.error "\fufufu is false"
		.end
	.endif
.endm

/*******************************************************************************
 * 
 * MIT License
 * 
 * Copyright (c) 2017 Advanced Micro Devices, Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 * 
 *******************************************************************************/

// Wrapper macros for some instructions.
// Macros contain workarounds for some assembler bugs.
// Also these allow for unifying source text when different
// ISA versions require different assembler syntax (mostly mnemonics).

.if ((.option.machine_version_major == 8) || (.option.machine_version_major == 9))
.else
    .error "Only Gfx8 and Gfx9 ISA is supported"
    .end
.endif

.ifndef WORKAROUND_BUG_34765
    .set WORKAROUND_BUG_34765,0
.endif

// Let's use Gfx10-like naming conventions for wrapper macros.
// ADD_NC
.macro _v_add_nc_u32 dst, src0, src1, dpp=
    .if (.option.machine_version_major == 8)
        // None No-Carry instruction in Gfx8, modifies VCC.
        v_add_u32 \dst, vcc, \src0, \src1 \dpp
    .else
        v_add_u32 \dst, \src0, \src1 \dpp
    .endif
.endm

// SUB_NC
.macro _v_sub_nc_u32 dst, src0, src1, dpp=
    .if (.option.machine_version_major == 8)
        // None No-Carry instruction in Gfx8, modifies VCC.
        v_sub_u32 \dst, vcc, \src0, \src1 \dpp
    .else
        v_sub_u32 \dst, \src0, \src1 \dpp
    .endif
.endm

// ADD_CO (gfx8 add)
.macro _v_add_co_u32 dst, co, src0, src1, dpp=
    .if ((.option.machine_version_major == 8) || ((.option.machine_version_major == 9) && (WORKAROUND_BUG_34765 == 1)))
        v_add_u32 \dst, \co, \src0, \src1 \dpp
    .else
        v_add_co_u32 \dst, \co, \src0, \src1 \dpp
    .endif
.endm

// ADD_CO_CI (gfx8 addc)
.macro _v_add_co_ci_u32 dst, co, src0, src1, ci, dpp=
    .if ((.option.machine_version_major == 8) || ((.option.machine_version_major == 9) && (WORKAROUND_BUG_34765 == 1)))
		v_addc_u32 \dst, \co, \src0, \src1, \ci \dpp
    .else
		v_addc_co_u32 \dst, \co, \src0, \src1, \ci \dpp
    .endif
.endm

// SUB_CO (gfx8 sub)
.macro _v_sub_co_u32 dst, co, src0, src1, dpp=
    .if ((.option.machine_version_major == 8) || ((.option.machine_version_major == 9) && (WORKAROUND_BUG_34765 == 1)))
        v_sub_u32 \dst, \co, \src0, \src1 \dpp
    .else
        v_sub_co_u32 \dst, \co, \src0, \src1 \dpp
    .endif
.endm

// SUBREV_CO (gfx8 subrev)
.macro _v_subrev_co_u32 dst, co, src0, src1, dpp=
    .if ((.option.machine_version_major == 8) || ((.option.machine_version_major == 9) && (WORKAROUND_BUG_34765 == 1)))
        v_subrev_u32 \dst, \co, \src0, \src1 \dpp
    .else
        v_subrev_co_u32 \dst, \co, \src0, \src1 \dpp
    .endif
.endm

.macro v_dot2 acc, in, out
    .if (.option.machine_version_major == 9) && (.option.machine_version_minor == 0) && (.option.machine_version_stepping == 6)
        v_dot2_f32_f16 v[\acc], v[\in], v[\out], v[\acc]
    .elseif (.option.machine_version_major == 9) && (.option.machine_version_stepping > 2)
        v_fma_mix_f32 v[\acc], v[\in], v[\out], v[\acc] op_sel:[0,0,0] op_sel_hi:[1,1,0]
        v_fma_mix_f32 v[\acc], v[\in], v[\out], v[\acc] op_sel:[1,1,0] op_sel_hi:[1,1,0]
    .else
        v_mad_mix_f32 v[\acc], v[\in], v[\out], v[\acc] op_sel:[0,0,0] op_sel_hi:[1,1,0]
        v_mad_mix_f32 v[\acc], v[\in], v[\out], v[\acc] op_sel:[1,1,0] op_sel_hi:[1,1,0]
    .endif
.endm




// kernarg layout:
kernarg = 4
in_desc = 0
.set in_ptr_off, 0x0
.set out_ptr_off, 0x8
.set scale_ptr_off, 0x10
.set bias_ptr_off, 0x18
.set inhw_off, 0x20
.if (MIO_SAVE_MEAN_VARIANCE == 1) && (MIO_RUNNING_RESULT == 1)
    .set expAvgFactor_off, 0x28
    .set resultRunningMean_off, 0x30
    .set resultRunningVariance_off, 0x38
    .set epsilon_off, 0x40
    .set resultSaveMean_off, 0x48
    .set resultSaveInvVariance_off, 0x50
.elseif (MIO_SAVE_MEAN_VARIANCE == 0) && (MIO_RUNNING_RESULT == 1)
    .set expAvgFactor_off, 0x28
    .set resultRunningMean_off, 0x30
    .set resultRunningVariance_off, 0x38
    .set epsilon_off, 0x40
    .set resultSaveMean_off, 0x0
    .set resultSaveInvVariance_off, 0x0
.elseif (MIO_SAVE_MEAN_VARIANCE == 1) && (MIO_RUNNING_RESULT == 0)
    .set expAvgFactor_off, 0x0
    .set resultRunningMean_off, 0x0
    .set resultRunningVariance_off, 0x0
    .set epsilon_off, 0x28
    .set resultSaveMean_off, 0x30
    .set resultSaveInvVariance_off, 0x38
.elseif (MIO_SAVE_MEAN_VARIANCE == 0) && (MIO_RUNNING_RESULT == 0)
    .set expAvgFactor_off, 0x0
    .set resultRunningMean_off, 0x0
    .set resultRunningVariance_off, 0x0
    .set epsilon_off, 0x28
    .set resultSaveMean_off, 0x0
    .set resultSaveInvVariance_off, 0x0
.endif

madmix_instructions_available = 0
fmamix_instructions_available = 0
.if (.option.machine_version_major == 9)
    .if(.option.machine_version_stepping > 2)
        fmamix_instructions_available = 1
    .else
        madmix_instructions_available = 1
    .endif
.endif

gcnAsmBNFwdTrainSpatial:

  .amd_kernel_code_t
    kernel_code_entry_byte_offset = 256
    kernel_code_prefetch_byte_size = 0
    granulated_workitem_vgpr_count = 3
    granulated_wavefront_sgpr_count = 4
    float_mode = 192
    enable_dx10_clamp = 1
    enable_ieee_mode = 1
    enable_sgpr_private_segment_wave_byte_offset = 1
    user_sgpr_count = 8
    enable_trap_handler = 0
    enable_sgpr_workgroup_id_x = 1
    enable_sgpr_workgroup_id_y = 0
    enable_sgpr_workgroup_id_z = 0
    enable_sgpr_workgroup_info = 0
    enable_vgpr_workitem_id = 0
    enable_sgpr_private_segment_buffer = 1
    enable_sgpr_kernarg_segment_ptr = 1
    enable_sgpr_private_segment_size = 0
    enable_sgpr_grid_workgroup_count_x = 0
    enable_sgpr_grid_workgroup_count_y = 0
    enable_sgpr_grid_workgroup_count_z = 0
    private_element_size = 1
    is_ptr64 = 1
    workitem_private_segment_byte_size = 132
    workgroup_group_segment_byte_size = 136
    gds_segment_byte_size = 0
    kernarg_segment_byte_size = 136
    workgroup_fbarrier_count = 0
    wavefront_sgpr_count = 40
    workitem_vgpr_count = 16
    debug_wavefront_private_segment_offset_sgpr = 0
    kernarg_segment_alignment = 4
    group_segment_alignment = 4
    private_segment_alignment = 4
    wavefront_size = 6
    call_convention = -1
  .end_amd_kernel_code_t


  s_mov_b32 s12, s8
  s_mov_b32 s13, 0
  v_cmp_eq_u32 s[10:11], 0, v0
  s_and_saveexec_b64 s[6:7], s[10:11]
  s_cbranch_execz skip_local_store

  // read scale ptr
    s_load_dwordx2 s[14:15], s[kernarg:kernarg+1], 0x0 + scale_ptr_off
  // read bias ptr
    s_load_dwordx2 s[16:17], s[kernarg:kernarg+1], 0x0 + bias_ptr_off
  s_lshl_b64 s[18:19], s[12:13], 2
  v_mov_b32 v1, 0
  s_waitcnt lgkmcnt(0)
  s_add_u32 s14, s14, s18
  s_addc_u32 s15, s15, s19
  s_add_u32 s16, s16, s18
  s_addc_u32 s17, s17, s19
  s_load_dword s8, s[14:15], 0x0
  s_load_dword s14, s[16:17], 0x0
  s_waitcnt lgkmcnt(0)
  v_mov_b32 v2, s8
  v_mov_b32 v3, s14
  ds_write2_b32 v1, v3, v2 offset1:1
skip_local_store:
  s_or_b64 exec, exec, s[6:7]
  s_waitcnt lgkmcnt(0)
  s_barrier
 // load input arguments...
  .if(MIO_SAVE_MEAN_VARIANCE)
     s_load_dwordx2 s[22:23], s[kernarg:kernarg+1], 0x0 + resultSaveMean_off
     s_load_dwordx2 s[20:21], s[kernarg:kernarg+1], 0x0 + resultSaveInvVariance_off
  .endif
  .if(MIO_RUNNING_RESULT)
     s_load_dwordx2 s[16:17], s[kernarg:kernarg+1], 0x0 + expAvgFactor_off
     s_load_dwordx2 s[18:19], s[kernarg:kernarg+1], 0x0 + resultRunningMean_off
     s_load_dwordx2 s[14:15], s[kernarg:kernarg+1], 0x0 + resultRunningVariance_off
  .endif
  s_load_dwordx2 s[24:25], s[kernarg:kernarg+1], 0x0 + out_ptr_off
  s_load_dword s26, s[kernarg:kernarg+1], 0x0 + inhw_off
  s_load_dwordx2 s[28:29], s[kernarg:kernarg+1], 0x0 + epsilon_off
  s_movk_i32 s6, 0+MIO_BN_HW
  v_mov_b32 v1, 0
  s_mul_i32 s8, s12, s6
  v_cmp_gt_u32 s[6:7], s6, v0
  v_mov_b32 v2, v1
  s_and_saveexec_b64 s[30:31], s[6:7]
  s_cbranch_execz skip_mini_batch_compute

 // load input ptr
   s_load_dwordx2 s[32:33], s[kernarg:kernarg+1], 0x0
  v_mov_b32 v1, 0
  _v_add_nc_u32 v3, s8, v0
  v_mov_b32 v5, 0
  v_mov_b32 v2, v1
mini_batch_compute:
  v_mov_b32 v4, 0
  v_lshlrev_b64 v[8:9], 1, v[3:4]
  _v_add_nc_u32 v6, 0+MIO_BN_CHW, v3
  v_mov_b32 v7, v4
  s_waitcnt lgkmcnt(0)
  v_mov_b32 v10, s33
  _v_add_co_u32 v8, s[4:5], s32, v8
  v_lshlrev_b64 v[6:7], 1, v[6:7]
  _v_add_co_ci_u32 v9, s[4:5], v10, v9, s[4:5]
  v_mov_b32 v11, s33
  _v_add_co_u32 v6, s[4:5], s32, v6
  _v_add_co_ci_u32 v7, s[4:5], v11, v7, s[4:5]
  flat_load_ushort v8, v[8:9]
  flat_load_ushort v6, v[6:7]
  _v_add_nc_u32 v12, 4, v5
  _v_add_nc_u32 v5, 4, v5
  _v_add_nc_u32 v4, 2, v12
  _v_add_nc_u32 v3, 0+MIO_BN_CHW*2, v3
  v_cmp_eq_u32 vcc, 0+MIO_BN_N*2, v5
  s_and_b64 vcc, exec, vcc
  s_waitcnt vmcnt(1) lgkmcnt(1)
  buffer_store_short v8, v12, s[0:3], s9 offen
  s_waitcnt vmcnt(1) lgkmcnt(0)
  buffer_store_short v6, v4, s[0:3], s9 offen
      .if(fmamix_instructions_available)
      v_mov_b32 v10, 0x3f800000
      v_fma_mix_f32 v1, v8, v8, v1 op_sel_hi:[1,1,0]
      v_fma_mix_f32 v1, v6, v6, v1 op_sel_hi:[1,1,0]
      v_fma_mix_f32 v2, v8, v10, v2 op_sel_hi:[1,0,0]
      v_fma_mix_f32 v2, v6, v10, v2 op_sel_hi:[1,0,0]
      .else
  v_cvt_f32_f16 v7, v8
  v_cvt_f32_f16 v8, v6
  v_add_f32 v2, v2, v7
  v_mac_f32 v1, v7, v7
  v_add_f32 v2, v2, v8
  v_mac_f32 v1, v8, v8
      .endif
  s_cbranch_vccz mini_batch_compute
skip_mini_batch_compute:
  s_or_b64 exec, exec, s[30:31]
  s_waitcnt vmcnt(0) lgkmcnt(0)
 // As multiple wavefronts are in a work-group (work group size is: 1024),
 // the S_BARRIER instruction is used here to force each wavefront to wait until all other wavefronts reach this point...
  s_barrier
 // (lid % 64)
  v_and_b32 v3, 63, v0
  v_cmp_eq_u32 vcc, 63, v3
  s_nop 4
 // DPP interleaved reduction...
 // v2 : mean and v1: variance...
  v_add_f32_dpp v2, v2, v2  row_shr:1 bound_ctrl:0
  v_add_f32_dpp v1, v1, v1  row_shr:1 bound_ctrl:0
  s_nop 0
  v_add_f32_dpp v2, v2, v2  row_shr:2 bound_ctrl:0
  v_add_f32_dpp v1, v1, v1  row_shr:2 bound_ctrl:0
  s_nop 0
  v_add_f32_dpp v2, v2, v2  row_shr:4 bank_mask:0xe
  v_add_f32_dpp v1, v1, v1  row_shr:4 bank_mask:0xe
  s_nop 0
  v_add_f32_dpp v2, v2, v2  row_shr:8 bank_mask:0xc
  v_add_f32_dpp v1, v1, v1  row_shr:8 bank_mask:0xc
  s_nop 0
  v_add_f32_dpp v2, v2, v2  row_bcast:15 row_mask:0xa
  v_add_f32_dpp v1, v1, v1  row_bcast:15 row_mask:0xa
  s_nop 0
  v_add_f32_dpp v2, v2, v2  row_bcast:31 row_mask:0xc
  v_add_f32_dpp v1, v1, v1  row_bcast:31 row_mask:0xc
  s_nop 0
  s_and_saveexec_b64 s[4:5], vcc
  v_lshrrev_b32 v3, 4, v0
  v_and_b32 v3, 60, v3
 // write mean and variance to LDS...
 // v2 : mean and v1: variance...
  ds_write2_b32 v3, v1, v2 offset0:2 offset1:18
  s_or_b64 exec, exec, s[4:5]
  s_waitcnt lgkmcnt(0)
  s_barrier
  v_mov_b32 v2, 0
  v_mov_b32 v3, 0
  v_mov_b32 v1, v2
bn_ldsgcn_size_loop:
  ds_read2_b32 v[4:5], v3 offset0:2 offset1:18
  _v_add_nc_u32 v3, 4, v3
  v_cmp_eq_u32 vcc, 0+MIO_BN_LDSGCN_SIZE*4, v3
  s_and_b64 vcc, exec, vcc
  s_waitcnt lgkmcnt(0)
  v_add_f32 v1, v1, v5
  v_add_f32 v2, v2, v4
 // if(VCC == 0) then continue in loop...
  s_cbranch_vccz bn_ldsgcn_size_loop
 // Force each wavefront to wait here until all other wavefronts reach this point...
  s_barrier
  v_cvt_f32_f64 v3, s[28:29]
  v_mul_f32 v1, s26, v1
  v_mul_f32 v4, v1, v1
  v_mad_f32 v2, v2, s26, -v4
  v_add_f32 v3, v2, v3
  v_rsq_f32 v3, v3
  s_and_saveexec_b64 s[26:27], s[6:7]
  s_cbranch_execz skip_bn_values_update
  v_mov_b32 v4, 0
  ds_read2_b32 v[7:8], v4 offset1:1
  _v_add_nc_u32 v5, s8, v0
bn_values_update:
  _v_add_nc_u32 v0, 4, v4
  _v_add_nc_u32 v6, 2, v0
  buffer_load_ushort v0, v0, s[0:3], s9 offen
  buffer_load_ushort v6, v6, s[0:3], s9 offen
  _v_add_nc_u32 v9, 0+MIO_BN_CHW, v5
  _v_add_nc_u32 v4, 4, v4
  v_mov_b32 v14, s25
  v_mov_b32 v15, s25
  s_waitcnt vmcnt(1)
  v_cvt_f32_f16 v0, v0
  s_waitcnt vmcnt(0)
  v_cvt_f32_f16 v6, v6
  v_sub_f32 v0, v0, v1
  v_sub_f32 v6, v6, v1
  v_mul_f32 v0, v3, v0
  v_mul_f32 v13, v3, v6
  v_mov_b32 v6, 0
  v_lshlrev_b64 v[11:12], 1, v[5:6]
  v_mov_b32 v10, v6
  s_waitcnt lgkmcnt(0)
        .if(fmamix_instructions_available)
  v_fma_mixlo_f16 v0, v8, v0, v7
  v_fma_mixlo_f16 v6, v8, v13, v7
        .else
  v_mad_f32 v0, v8, v0, v7
  v_mad_f32 v6, v8, v13, v7
  v_cvt_f16_f32 v0, v0
  v_cvt_f16_f32 v6, v6
        .endif
  v_lshlrev_b64 v[9:10], 1, v[9:10]
  _v_add_nc_u32 v5, 0+MIO_BN_CHW*2, v5
  v_cmp_eq_u32 vcc, 0+MIO_BN_N*2, v4
  _v_add_co_u32 v11, s[4:5], s24, v11
  _v_add_co_u32 v9, s[6:7], s24, v9
  s_and_b64 vcc, exec, vcc
  _v_add_co_ci_u32 v10, s[6:7], v15, v10, s[6:7]
  _v_add_co_ci_u32 v12, s[4:5], v14, v12, s[4:5]
  flat_store_short v[11:12], v0
  flat_store_short v[9:10], v6
  s_cbranch_vccz bn_values_update
skip_bn_values_update:
  s_or_b64 exec, exec, s[26:27]
  s_and_saveexec_b64 s[4:5], s[10:11]
 // if(lid != 0) go to end of program...
 // Branch if all lanes fail...
  s_cbranch_execz end_of_program

  s_lshl_b64 s[4:5], s[12:13], 2
  s_add_u32 s6, s22, s4
  s_addc_u32 s7, s23, s5
  v_mov_b32 v4, s6
  v_mov_b32 v5, s7
  s_add_u32 s6, s20, s4
  s_addc_u32 s7, s21, s5
  v_mov_b32 v6, s6
  v_mov_b32 v7, s7
  s_add_u32 s6, s18, s4
  s_addc_u32 s7, s19, s5
  s_add_u32 s4, s14, s4
        .if(MIO_SAVE_MEAN_VARIANCE)
  flat_store_dword v[4:5], v1
  flat_store_dword v[6:7], v3
        .endif
  s_addc_u32 s5, s15, s5
  v_mov_b32 v3, s6
  v_mov_b32 v6, s5
  v_mov_b32 v4, s7
  v_mov_b32 v5, s4
        .if(MIO_RUNNING_RESULT)
  flat_load_dword v8, v[3:4]
  flat_load_dword v9, v[5:6]
  v_cvt_f32_f64 v0, s[16:17]
  v_mul_f32 v2, 0+MIO_BN_NHW_DIV, v2
  v_sub_f32 v7, 1.0, v0
  v_mul_f32 v2, v2, v0
  s_waitcnt vmcnt(1) lgkmcnt(1)
  v_mad_f32 v8, -v0, v8, v8
  v_mac_f32 v8, v1, v0
  s_waitcnt vmcnt(0) lgkmcnt(0)
  v_mac_f32 v2, v7, v9
  flat_store_dword v[3:4], v8
  flat_store_dword v[5:6], v2
        .endif
end_of_program:
  s_endpgm

.Lfunc_end0:
    .size gcnAsmBNFwdTrainSpatial, .Lfunc_end0 - gcnAsmBNFwdTrainSpatial

ROCM_METADATA_VERSION = 4 /// \todo This should come from the host.

.macro metadata wg_x, save_flag, result_running_flag
  .if ROCM_METADATA_VERSION == 4
    .if (\save_flag == 1) && (\result_running_flag == 1)
      .amd_amdgpu_hsa_metadata
      { Version: [ 1, 0 ],
           Kernels:
           -  { Name: gcnAsmBNFwdTrainSpatial, SymbolName: 'gcnAsmBNFwdTrainSpatial@kd', Language: OpenCL C, LanguageVersion: [ 1, 2 ],
               Attrs:
                 { ReqdWorkGroupSize: [ \wg_x, 1, 1 ] }
                 CodeProps:
                 { KernargSegmentSize: 136, GroupSegmentFixedSize: 136, PrivateSegmentFixedSize: 132, KernargSegmentAlign: 8, WavefrontSize: 64, NumSGPRs: 40, NumVGPRs: 12, MaxFlatWorkGroupSize: \wg_x }
                 Args:
                 - { Name: in      , Size: 8, Align: 8, ValueKind: GlobalBuffer, ValueType: F16, TypeName: 'half*', AddrSpaceQual: Global, AccQual: ReadOnly, IsConst: true, IsRestrict: true}
                 - { Name: out     , Size: 8, Align: 8, ValueKind: GlobalBuffer, ValueType: F16, TypeName: 'half*', AddrSpaceQual: Global, AccQual: Default, IsRestrict: true}
                 - { Name: scale   , Size: 8, Align: 8, ValueKind: GlobalBuffer, ValueType: F32, TypeName: 'float*', AddrSpaceQual: Constant, AccQual: ReadOnly, IsConst: true, IsRestrict: true}
                 - { Name: bias    , Size: 8, Align: 8, ValueKind: GlobalBuffer, ValueType: F32, TypeName: 'float*', AddrSpaceQual: Constant, AccQual: ReadOnly, IsConst: true, IsRestrict: true}
                 - { Name: INHW    , Size: 4, Align: 4, ValueKind: ByValue, ValueType: F32, TypeName: 'float', AccQual: Default }
                 - { Name: expAvgFactor    , Size: 8, Align: 8, ValueKind: ByValue, ValueType: F64, TypeName: 'double', AccQual: Default }
                 - { Name: resultRunningMean,  Size: 8, Align: 8, ValueKind: GlobalBuffer, ValueType: F32, TypeName: 'float*', AddrSpaceQual: Global, AccQual: Default, IsRestrict: true}
                 - { Name: resultRunningVariance, Size: 8, Align: 8, ValueKind: GlobalBuffer, ValueType: F32, TypeName: 'float*', AddrSpaceQual: Global, AccQual: Default, IsRestrict: true}
                 - { Name: epsilon, Size: 8, Align: 8, ValueKind: ByValue, ValueType: F64, TypeName: 'double', AccQual: Default }
                 - { Name: resultSaveMean, Size: 8, Align: 8, ValueKind: GlobalBuffer, ValueType: F32, TypeName: 'float*', AddrSpaceQual: Global, AccQual: Default, IsRestrict: true}
                 - { Name: resultSaveInvVariance, Size: 8, Align: 8, ValueKind: GlobalBuffer, ValueType: F32, TypeName: 'float*', AddrSpaceQual: Global, AccQual: Default, IsRestrict: true}
                 //- { Name: HiddenGlobalOffsetX, Size: 8, Align: 8, ValueKind: ByValue, ValueType: I64 }
                 //- { Name: HiddenGlobalOffsetY, Size: 8, Align: 8, ValueKind: ByValue, ValueType: I64 }
                 //- { Name: HiddenGlobalOffsetZ, Size: 8, Align: 8, ValueKind: ByValue, ValueType: I64 }
               }
      }
      .end_amd_amdgpu_hsa_metadata
    .elseif (\save_flag == 0) && (\result_running_flag == 1)
      .amd_amdgpu_hsa_metadata
      { Version: [ 1, 0 ],
           Kernels:
           -  { Name: gcnAsmBNFwdTrainSpatial, SymbolName: 'gcnAsmBNFwdTrainSpatial@kd', Language: OpenCL C, LanguageVersion: [ 1, 2 ],
               Attrs:
                 { ReqdWorkGroupSize: [ \wg_x, 1, 1 ] }
                 CodeProps:
                 { KernargSegmentSize: 136, GroupSegmentFixedSize: 136, PrivateSegmentFixedSize: 132, KernargSegmentAlign: 8, WavefrontSize: 64, NumSGPRs: 40, NumVGPRs: 12, MaxFlatWorkGroupSize: \wg_x }
                 Args:
                 - { Name: in      , Size: 8, Align: 8, ValueKind: GlobalBuffer, ValueType: F16, TypeName: 'half*', AddrSpaceQual: Global, AccQual: ReadOnly, IsConst: true, IsRestrict: true}
                 - { Name: out     , Size: 8, Align: 8, ValueKind: GlobalBuffer, ValueType: F16, TypeName: 'half*', AddrSpaceQual: Global, AccQual: Default, IsRestrict: true}
                 - { Name: scale   , Size: 8, Align: 8, ValueKind: GlobalBuffer, ValueType: F32, TypeName: 'float*', AddrSpaceQual: Constant, AccQual: ReadOnly, IsConst: true, IsRestrict: true}
                 - { Name: bias    , Size: 8, Align: 8, ValueKind: GlobalBuffer, ValueType: F32, TypeName: 'float*', AddrSpaceQual: Constant, AccQual: ReadOnly, IsConst: true, IsRestrict: true}
                 - { Name: INHW    , Size: 4, Align: 4, ValueKind: ByValue, ValueType: F32, TypeName: 'float', AccQual: Default }
                 - { Name: expAvgFactor    , Size: 8, Align: 8, ValueKind: ByValue, ValueType: F64, TypeName: 'double', AccQual: Default }
                 - { Name: resultRunningMean,  Size: 8, Align: 8, ValueKind: GlobalBuffer, ValueType: F32, TypeName: 'float*', AddrSpaceQual: Global, AccQual: Default, IsRestrict: true}
                 - { Name: resultRunningVariance, Size: 8, Align: 8, ValueKind: GlobalBuffer, ValueType: F32, TypeName: 'float*', AddrSpaceQual: Global, AccQual: Default, IsRestrict: true}
                 - { Name: epsilon, Size: 8, Align: 8, ValueKind: ByValue, ValueType: F64, TypeName: 'double', AccQual: Default }
                 //- { Name: HiddenGlobalOffsetX, Size: 8, Align: 8, ValueKind: ByValue, ValueType: I64 }
                 //- { Name: HiddenGlobalOffsetY, Size: 8, Align: 8, ValueKind: ByValue, ValueType: I64 }
                 //- { Name: HiddenGlobalOffsetZ, Size: 8, Align: 8, ValueKind: ByValue, ValueType: I64 }
               }
      }
      .end_amd_amdgpu_hsa_metadata
    .elseif (\save_flag == 1) && (\result_running_flag == 0)
      .amd_amdgpu_hsa_metadata
      { Version: [ 1, 0 ],
           Kernels:
           -  { Name: gcnAsmBNFwdTrainSpatial, SymbolName: 'gcnAsmBNFwdTrainSpatial@kd', Language: OpenCL C, LanguageVersion: [ 1, 2 ],
               Attrs:
                 { ReqdWorkGroupSize: [ \wg_x, 1, 1 ] }
                 CodeProps:
                 { KernargSegmentSize: 136, GroupSegmentFixedSize: 136, PrivateSegmentFixedSize: 132, KernargSegmentAlign: 8, WavefrontSize: 64, NumSGPRs: 40, NumVGPRs: 12, MaxFlatWorkGroupSize: \wg_x }
                 Args:
                 - { Name: in      , Size: 8, Align: 8, ValueKind: GlobalBuffer, ValueType: F16, TypeName: 'half*', AddrSpaceQual: Global, AccQual: ReadOnly, IsConst: true, IsRestrict: true}
                 - { Name: out     , Size: 8, Align: 8, ValueKind: GlobalBuffer, ValueType: F16, TypeName: 'half*', AddrSpaceQual: Global, AccQual: Default, IsRestrict: true}
                 - { Name: scale   , Size: 8, Align: 8, ValueKind: GlobalBuffer, ValueType: F32, TypeName: 'float*', AddrSpaceQual: Constant, AccQual: ReadOnly, IsConst: true, IsRestrict: true}
                 - { Name: bias    , Size: 8, Align: 8, ValueKind: GlobalBuffer, ValueType: F32, TypeName: 'float*', AddrSpaceQual: Constant, AccQual: ReadOnly, IsConst: true, IsRestrict: true}
                 - { Name: INHW    , Size: 4, Align: 4, ValueKind: ByValue, ValueType: F32, TypeName: 'float', AccQual: Default }
                 - { Name: epsilon, Size: 8, Align: 8, ValueKind: ByValue, ValueType: F64, TypeName: 'double', AccQual: Default }
                 - { Name: resultSaveMean, Size: 8, Align: 8, ValueKind: GlobalBuffer, ValueType: F32, TypeName: 'float*', AddrSpaceQual: Global, AccQual: Default, IsRestrict: true}
                 - { Name: resultSaveInvVariance, Size: 8, Align: 8, ValueKind: GlobalBuffer, ValueType: F32, TypeName: 'float*', AddrSpaceQual: Global, AccQual: Default, IsRestrict: true}
                 //- { Name: HiddenGlobalOffsetX, Size: 8, Align: 8, ValueKind: ByValue, ValueType: I64 }
                 //- { Name: HiddenGlobalOffsetY, Size: 8, Align: 8, ValueKind: ByValue, ValueType: I64 }
                 //- { Name: HiddenGlobalOffsetZ, Size: 8, Align: 8, ValueKind: ByValue, ValueType: I64 }
               }
      }
      .end_amd_amdgpu_hsa_metadata
    .elseif (\save_flag == 0) && (\result_running_flag == 0)
      .amd_amdgpu_hsa_metadata
      { Version: [ 1, 0 ],
           Kernels:
           -  { Name: gcnAsmBNFwdTrainSpatial, SymbolName: 'gcnAsmBNFwdTrainSpatial@kd', Language: OpenCL C, LanguageVersion: [ 1, 2 ],
               Attrs:
                 { ReqdWorkGroupSize: [ \wg_x, 1, 1 ] }
                 CodeProps:
                 { KernargSegmentSize: 136, GroupSegmentFixedSize: 136, PrivateSegmentFixedSize: 132, KernargSegmentAlign: 8, WavefrontSize: 64, NumSGPRs: 40, NumVGPRs: 12, MaxFlatWorkGroupSize: \wg_x }
                 Args:
                 - { Name: in      , Size: 8, Align: 8, ValueKind: GlobalBuffer, ValueType: F16, TypeName: 'half*', AddrSpaceQual: Global, AccQual: ReadOnly, IsConst: true, IsRestrict: true}
                 - { Name: out     , Size: 8, Align: 8, ValueKind: GlobalBuffer, ValueType: F16, TypeName: 'half*', AddrSpaceQual: Global, AccQual: Default, IsRestrict: true}
                 - { Name: scale   , Size: 8, Align: 8, ValueKind: GlobalBuffer, ValueType: F32, TypeName: 'float*', AddrSpaceQual: Constant, AccQual: ReadOnly, IsConst: true, IsRestrict: true}
                 - { Name: bias    , Size: 8, Align: 8, ValueKind: GlobalBuffer, ValueType: F32, TypeName: 'float*', AddrSpaceQual: Constant, AccQual: ReadOnly, IsConst: true, IsRestrict: true}
                 - { Name: INHW    , Size: 4, Align: 4, ValueKind: ByValue, ValueType: F32, TypeName: 'float', AccQual: Default }
                 - { Name: epsilon, Size: 8, Align: 8, ValueKind: ByValue, ValueType: F64, TypeName: 'double', AccQual: Default }
                 //- { Name: HiddenGlobalOffsetX, Size: 8, Align: 8, ValueKind: ByValue, ValueType: I64 }
                 //- { Name: HiddenGlobalOffsetY, Size: 8, Align: 8, ValueKind: ByValue, ValueType: I64 }
                 //- { Name: HiddenGlobalOffsetZ, Size: 8, Align: 8, ValueKind: ByValue, ValueType: I64 }
               }
      }
      .end_amd_amdgpu_hsa_metadata
    .endif
  .else
    .error "Unsupported ROCM_METADATA_VERSION"
    .end
  .endif
.endm

//.if MIO_BN_GRP0 == 832
//    metadata 832
//.else
//    metadata 1024
//.endif

.altmacro
.macro metadata_wrapper wg_x, save_flag, result_running_flag
    metadata %\wg_x, %\save_flag, %\result_running_flag
.endm

static_assert(MIO_BN_GRP1 == 1 && MIO_BN_GRP2 == 1)
metadata_wrapper MIO_BN_GRP0, MIO_SAVE_MEAN_VARIANCE, MIO_RUNNING_RESULT

//metadata 1024
//metadata 832
//metadata 0+MIO_BN_GRP0

        .hsa_code_object_version 2,1
.hsa_code_object_isa

.text
.globl gcnAsmWinogradXformOut
.p2align 8
.type gcnAsmWinogradXformOut,@function
.amdgpu_hsa_kernel gcnAsmWinogradXformOut

/*******************************************************************************
 * 
 * MIT License
 * 
 * Copyright (c) 2017 Advanced Micro Devices, Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 * 
 *******************************************************************************/

// Wrapper macros for some instructions.
// Macros contain workarounds for some assembler bugs.
// Also these allow for unifying source text when different
// ISA versions require different assembler syntax (mostly mnemonics).

.if ((.option.machine_version_major == 8) || (.option.machine_version_major == 9))
.else
    .error "Only Gfx8 and Gfx9 ISA is supported"
    .end
.endif

.ifndef WORKAROUND_BUG_34765
    .set WORKAROUND_BUG_34765,0
.endif

// Let's use Gfx10-like naming conventions for wrapper macros.
// ADD_NC
.macro _v_add_nc_u32 dst, src0, src1, dpp=
    .if (.option.machine_version_major == 8)
        // None No-Carry instruction in Gfx8, modifies VCC.
        v_add_u32 \dst, vcc, \src0, \src1 \dpp
    .else
        v_add_u32 \dst, \src0, \src1 \dpp
    .endif
.endm

// SUB_NC
.macro _v_sub_nc_u32 dst, src0, src1, dpp=
    .if (.option.machine_version_major == 8)
        // None No-Carry instruction in Gfx8, modifies VCC.
        v_sub_u32 \dst, vcc, \src0, \src1 \dpp
    .else
        v_sub_u32 \dst, \src0, \src1 \dpp
    .endif
.endm

// ADD_CO (gfx8 add)
.macro _v_add_co_u32 dst, co, src0, src1, dpp=
    .if ((.option.machine_version_major == 8) || ((.option.machine_version_major == 9) && (WORKAROUND_BUG_34765 == 1)))
        v_add_u32 \dst, \co, \src0, \src1 \dpp
    .else
        v_add_co_u32 \dst, \co, \src0, \src1 \dpp
    .endif
.endm

// ADD_CO_CI (gfx8 addc)
.macro _v_add_co_ci_u32 dst, co, src0, src1, ci, dpp=
    .if ((.option.machine_version_major == 8) || ((.option.machine_version_major == 9) && (WORKAROUND_BUG_34765 == 1)))
		v_addc_u32 \dst, \co, \src0, \src1, \ci \dpp
    .else
		v_addc_co_u32 \dst, \co, \src0, \src1, \ci \dpp
    .endif
.endm

// SUB_CO (gfx8 sub)
.macro _v_sub_co_u32 dst, co, src0, src1, dpp=
    .if ((.option.machine_version_major == 8) || ((.option.machine_version_major == 9) && (WORKAROUND_BUG_34765 == 1)))
        v_sub_u32 \dst, \co, \src0, \src1 \dpp
    .else
        v_sub_co_u32 \dst, \co, \src0, \src1 \dpp
    .endif
.endm

// SUBREV_CO (gfx8 subrev)
.macro _v_subrev_co_u32 dst, co, src0, src1, dpp=
    .if ((.option.machine_version_major == 8) || ((.option.machine_version_major == 9) && (WORKAROUND_BUG_34765 == 1)))
        v_subrev_u32 \dst, \co, \src0, \src1 \dpp
    .else
        v_subrev_co_u32 \dst, \co, \src0, \src1 \dpp
    .endif
.endm

.macro v_dot2 acc, in, out
    .if (.option.machine_version_major == 9) && (.option.machine_version_minor == 0) && (.option.machine_version_stepping == 6)
        v_dot2_f32_f16 v[\acc], v[\in], v[\out], v[\acc]
    .elseif (.option.machine_version_major == 9) && (.option.machine_version_stepping > 2)
        v_fma_mix_f32 v[\acc], v[\in], v[\out], v[\acc] op_sel:[0,0,0] op_sel_hi:[1,1,0]
        v_fma_mix_f32 v[\acc], v[\in], v[\out], v[\acc] op_sel:[1,1,0] op_sel_hi:[1,1,0]
    .else
        v_mad_mix_f32 v[\acc], v[\in], v[\out], v[\acc] op_sel:[0,0,0] op_sel_hi:[1,1,0]
        v_mad_mix_f32 v[\acc], v[\in], v[\out], v[\acc] op_sel:[1,1,0] op_sel_hi:[1,1,0]
    .endif
.endm



/*******************************************************************************
 *
 * MIT License
 *
 * Copyright (c) 2017 Advanced Micro Devices, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 *******************************************************************************/

.set __auto_gpr_count_guard, 1

.set .WAVE_SIZE, 64
.set .WAVE_SIZE_LOG2, 6
.set .MAX_VGPRS, 256
.set .MAX_SGPRS, 102
.set .MAX_LDS, 65536

.macro .GPR_ALLOC_BEGIN
    .set .AVAILABLE_VGPRS, .MAX_VGPRS
    .set .AVAILABLE_SGPRS, .MAX_SGPRS
	.set .AVAILABLE_LDS, .MAX_LDS
	.set .SGPR_NEXT_FREE, 0
	.set .VGPR_NEXT_FREE, 0
	.set .LDS_NEXT_FREE, 0
	.set .AUTO_VGPR_COUNT, 0
	.set .AUTO_SGPR_COUNT, 0
	.set .AUTO_LDS_BYTE_SIZE, 0
.ifnotdef EXPERIMENTAL_COv3	
	.set .AUTO_VGPR_GRANULATED_COUNT, 0
	.set .AUTO_SGPR_GRANULATED_COUNT, 0
.endif	
	.set __sgpr_reserve_vcc, 0
	.set __sgpr_reserve_xnack, 0
	.set __sgpr_reserve_flatscr, 0
	.set __auto_gpr_count_guard, 0
	.set __max_waves_limit, 10
	.set __min_waves_limit, 1
.endm

.macro .CHECK_SGPR_ALLOCATION gprs_to_allocate=0
	.if (.SGPR_NEXT_FREE + \gprs_to_allocate) > .AVAILABLE_SGPRS
		.error "Error: out of free sgprs"
        .end
	.endif
.endm

.macro .CHECK_VGPR_ALLOCATION gprs_to_allocate=0
	.if (.VGPR_NEXT_FREE + \gprs_to_allocate) > .AVAILABLE_VGPRS
		.error "Error: out of free vgprs"
        .end
	.endif
.endm

.macro .CHECK_LDS_ALLOCATION bytes_to_allocate=0
	.if (.LDS_NEXT_FREE + \bytes_to_allocate) > .AVAILABLE_LDS
		.error "Error: out of free lds"
        .end
	.endif
.endm

.macro .GPRS_FOR_WAVE_LIMIT waves_per_simd, sgprs, vgprs
    .if \waves_per_simd == 10
	    \sgprs = 80
		\vgprs = 24
	.elseif \waves_per_simd == 9
	    \sgprs = 96
		\vgprs = 28
	.elseif \waves_per_simd == 8
	    \sgprs = 96
		\vgprs = 32
	.elseif \waves_per_simd == 7
	    \sgprs = 102
		\vgprs = 36
	.elseif \waves_per_simd == 6
	    \sgprs = 102
		\vgprs = 40
	.elseif \waves_per_simd == 5
	    \sgprs = 102
		\vgprs = 48
	.elseif \waves_per_simd == 4
	    \sgprs = 102
		\vgprs = 64
	.elseif \waves_per_simd == 3
	    \sgprs = 102
		\vgprs = 84
	.elseif \waves_per_simd == 2
	    \sgprs = 102
		\vgprs = 128
	.else
	    \sgprs = 102
		\vgprs = 256
	.endif
.endm

.macro .SET_MIN_WAVES_LIMIT waves_per_simd
    .if \waves_per_simd > 10
		.error "Error: max 10 waves per simd is available"
	.endif
	.GPRS_FOR_WAVE_LIMIT \waves_per_simd, .AVAILABLE_SGPRS, .AVAILABLE_VGPRS
	.CHECK_SGPR_ALLOCATION
	.CHECK_VGPR_ALLOCATION
	__min_waves_limit = \waves_per_simd
	.if __min_waves_limit > __max_waves_limit
	    .error "Error: __min_waves_limit > __max_waves_limit"
	.endif
.endm

.macro .SET_MAX_WAVES_LIMIT waves_per_simd
    .if \waves_per_simd < 1
		.error "Error: waves per simd should be > 0"
	.endif
	__max_waves_limit = \waves_per_simd
	.if __min_waves_limit > __max_waves_limit
	    .error "Error: __min_waves_limit > __max_waves_limit"
	.endif
.endm


.macro .GPR_ALLOC_END
    .if __auto_gpr_count_guard == 1
	    .error "Error: unpaired .GPR_ALLOC_END. Please invoke .GPR_ALLOC_BEGIN before each kernel."
	.endif
	.CHECK_SGPR_ALLOCATION
	.CHECK_VGPR_ALLOCATION
	.CHECK_LDS_ALLOCATION
	__sgpr_additional_count = 2 * (__sgpr_reserve_flatscr + __sgpr_reserve_xnack + __sgpr_reserve_vcc)
	.GPRS_FOR_WAVE_LIMIT __max_waves_limit, .AUTO_SGPR_COUNT, .AUTO_VGPR_COUNT
	.if .AUTO_VGPR_COUNT < .VGPR_NEXT_FREE
	    .AUTO_VGPR_COUNT = .VGPR_NEXT_FREE
	.endif
	.if .AUTO_SGPR_COUNT < (.SGPR_NEXT_FREE + __sgpr_additional_count)
	    .AUTO_SGPR_COUNT = (.SGPR_NEXT_FREE + __sgpr_additional_count)
	.endif
.ifnotdef EXPERIMENTAL_COv3	
	.AUTO_VGPR_GRANULATED_COUNT = (.AUTO_VGPR_COUNT - 1)/4
	.AUTO_SGPR_GRANULATED_COUNT = (.AUTO_SGPR_COUNT - 1)/8
.endif	
	.AUTO_LDS_BYTE_SIZE = .LDS_NEXT_FREE
    __auto_gpr_count_guard = 1
.endm

.macro .VGPR_ALLOC_FROM __vgpr_alloc_from
    .set .VGPR_NEXT_FREE, \__vgpr_alloc_from
.endm

.macro .SGPR_ALLOC_FROM __sgpr_alloc_from
    .set .SGPR_NEXT_FREE, \__sgpr_alloc_from
.endm

.macro .LDS_ALLOC_FROM __lds_alloc_from
	.set .LDS_NEXT_FREE, \__lds_alloc_from
.endm

.macro .SGPR_RESERVE_FLATSCR
    .set __sgpr_reserve_flatscr, 1
.endm

.macro .SGPR_RESERVE_XNACK
    .set __sgpr_reserve_xnack, 1
.endm

.macro .SGPR_RESERVE_VCC
    .set __sgpr_reserve_vcc, 1
.endm

.macro .VGPR_ALLOC __vgpr_number_symbolic, __vgpr_numregs=1
    .CHECK_VGPR_ALLOCATION \__vgpr_numregs
    .set \__vgpr_number_symbolic, .VGPR_NEXT_FREE
    .set .VGPR_NEXT_FREE, .VGPR_NEXT_FREE + \__vgpr_numregs
.endm

.macro .SGPR_ALLOC __sgpr_number_symbolic, __sgpr_numregs=1, __sgpr_alignment=0
    .CHECK_SGPR_ALLOCATION \__sgpr_numregs
	.if \__sgpr_alignment > 0
		.set __sgpr_effective_alignment, \__sgpr_alignment
	.elseif \__sgpr_numregs > 4
		.set __sgpr_effective_alignment, 4
	.else
		.set __sgpr_effective_alignment, \__sgpr_numregs
	.endif
    .if .SGPR_NEXT_FREE % __sgpr_effective_alignment != 0
		.error "Error: unaligned register"
    .endif
    .set \__sgpr_number_symbolic, .SGPR_NEXT_FREE
    .set .SGPR_NEXT_FREE, .SGPR_NEXT_FREE + \__sgpr_numregs
.endm

.macro .LDS_ALLOC __lds_ptr_name, __bytes_to_allocate, __alignment_size=1
	.if .LDS_NEXT_FREE % \__alignment_size != 0
		.LDS_ALLOC_FROM ((.LDS_NEXT_FREE / \__alignment_size) + 1) * \__alignment_size
	.endif
	.CHECK_LDS_ALLOCATION \__bytes_to_allocate
	.set \__lds_ptr_name, .LDS_NEXT_FREE
	.set .LDS_NEXT_FREE, .LDS_NEXT_FREE + \__bytes_to_allocate
.endm

.macro .SGPR_ALLOC_ONCE __sgpr_symbolic, __sgpr_numregs=1, __sgpr_alignment=0
	.ifndef __guard_sgpr_\__sgpr_symbolic
		__guard_sgpr_\__sgpr_symbolic = 0
	.endif
	.if __guard_sgpr_\__sgpr_symbolic == 0
		__guard_sgpr_\__sgpr_symbolic = 1
		.SGPR_ALLOC \__sgpr_symbolic, \__sgpr_numregs, \__sgpr_alignment
	.endif
.endm

.macro .GPR_INVALIDATE __gpr_symbolic
	.set \__gpr_symbolic, 0x7fffffff /* invalidate (intentionally to the middle of the int range) */
.endm

.macro .GPR_REUSE __gpr_number_symbolic_old, __gpr_number_symbolic_new
    .set \__gpr_number_symbolic_new, \__gpr_number_symbolic_old
    .GPR_INVALIDATE \__gpr_number_symbolic_old
.endm

/*******************************************************************************
 *
 * MIT License
 *
 * Copyright (c) 2017 Advanced Micro Devices, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 *******************************************************************************/

.ifdef EXPERIMENTAL_COv3
    .ifdef .option.machine_version_major
        .error ".option.machine_version_major already defined"
        .end
    .endif
    .set .option.machine_version_major, .amdgcn.gfx_generation_number
.endif

LAYOUT_DATA_NCHW = 0
LAYOUT_DATA_CNHW = 1
LAYOUT_DATA_NHWC = 2
LAYOUT_DATA_CHWN = 3

// acc_type and buf_type: 0 - FP64, 1 - FP32, 2 - FP16, 5 - int32, 6 - int16, 7 - int8
TYPE_FP64  = 0
TYPE_FP32  = 1
TYPE_FP16  = 2
TYPE_BFP16 = 3
TYPE_INT64 = 4
TYPE_INT32 = 5
TYPE_INT16 = 6
TYPE_INT8  = 7
TYPE_INT4  = 8

.macro log2 lg2, num, max_bits=8
    \lg2 = 0
    lg_i = \num
    .rept \max_bits
        lg_i = lg_i / 2
        .if lg_i > 0
            \lg2 = \lg2 + 1
        .endif
    .endr
.endm

.macro default symbol, value
    .ifnotdef \symbol
        \symbol = \value
    .endif
.endm

.macro static_assert fufufu
    .if !\fufufu
        .error "\fufufu is false"
        .end
    .endif
.endm

.macro swap a, b
    __tmp = \a
    \a = \b
    \b = __tmp
.endm

.macro m_bpermute vgpr, cnt, addr
    v = \vgpr
    .rept \cnt
        ds_bpermute_b32 v[v], v[\addr], v[v]
        v = v + 1
    .endr
.endm

.macro m_swizzle vgpr, cnt, pattern
    v = \vgpr
    .rept \cnt
        ds_swizzle_b32 v[v], v[v] offset:\pattern
        v = v + 1
    .endr
.endm

.if (.option.machine_version_major == 8)
    .set max_hw_vctn, 15
.elseif (.option.machine_version_major == 9)
    .set max_hw_vctn, 63
.endif
max_hw_lcnt = 15
.macro s_wait vmcnt=max_hw_vctn, lgkmcnt=max_hw_lcnt
    vm_cnt = \vmcnt
    lgkm_cnt = \lgkmcnt
    .if vm_cnt > max_hw_vctn
        vm_cnt = max_hw_vctn
    .elseif vm_cnt < 0
        vm_cnt = 0
    .endif
    .if lgkm_cnt > max_hw_lcnt
        lgkm_cnt = max_hw_lcnt
    .elseif lgkm_cnt < 0
        lgkm_cnt = 0
    .endif
    s_waitcnt vmcnt(0 + vm_cnt) & lgkmcnt(0 + lgkm_cnt)
.endm


maxU24 = 1 << 24

wave_size = 64
log2 wave_size_log2, wave_size

.macro m_buffer_load_dwordx size, dst, off, desc, soff, ioff=0
    .if \size == 1
        buffer_load_dword v[\dst], v[\off], s[\desc:\desc + 3], s[\soff] offen offset:0+\ioff
    .elseif \size == 2
        buffer_load_dwordx2 v[\dst:\dst+\size-1], v[\off], s[\desc:\desc + 3], s[\soff] offen offset:0+\ioff
    .elseif \size == 3
        buffer_load_dwordx3 v[\dst:\dst+\size-1], v[\off], s[\desc:\desc + 3], s[\soff] offen offset:0+\ioff
    .elseif \size == 4
        buffer_load_dwordx4 v[\dst:\dst+\size-1], v[\off], s[\desc:\desc + 3], s[\soff] offen offset:0+\ioff
    .endif
.endm

.macro m_buffer_load_ushort size, dst, off, desc, soff, ioff=0
    .if \size == 1
        buffer_load_ushort v[\dst], v[\off],  s[\desc:\desc + 3], s[\soff] offen offset:0+\ioff
    .endif
.endm

.macro m_buffer_store_short size, src, off, desc, soff, ioff=0
    .if \size == 1
        buffer_store_short v[\src], v[\off],  s[\desc:\desc + 3], s[\soff] offen offset:0+\ioff
    .endif
.endm

.macro u32_div numer, denom, uquo, v_tmp, s_tmp
    u_div   v[\numer], v[\denom] v[\uquo], \v_tmp, \s_tmp, \s_tmp + 2 
.endm


// Unsigned division function from the SC implementation
// 4 s_tmps, 4 v_tmps
//
.macro u_div numer, denom, uquo, vtmp, stmp1, stmp2
    v_cvt_f32_u32     v[\vtmp],     \denom
    v_rcp_f32         v[\vtmp],     v[\vtmp]
    v_mul_f32         v[\vtmp],     0x4f800000,   v[\vtmp]
    v_cvt_u32_f32     v[\vtmp],     v[\vtmp]

    v_mul_lo_u32      v[\vtmp+1],   \denom,       v[\vtmp]
    v_mul_hi_u32      v[\vtmp+2],   \denom,       v[\vtmp]
   _v_sub_co_u32      v[\vtmp+3],   vcc,          0,           v[\vtmp+1]
    v_cmp_ne_i32      s[\stmp1:\stmp1+1], 0,      v[\vtmp+2]
    v_cndmask_b32     v[\vtmp+1],   v[\vtmp+3],   v[\vtmp+1],  s[\stmp1:\stmp1+1]
    v_mul_hi_u32      v[\vtmp+1],   v[\vtmp+1],   v[\vtmp]
   _v_sub_co_u32      v[\vtmp+2],   vcc,          v[\vtmp],    v[\vtmp+1]
    v_add_co_u32      v[\vtmp],     vcc,          v[\vtmp],    v[\vtmp+1]
    v_cndmask_b32     v[\vtmp],     v[\vtmp],     v[\vtmp+2],  s[\stmp1:\stmp1+1]
    v_mul_hi_u32      v[\vtmp],     v[\vtmp],     \numer
    v_mul_lo_u32      v[\vtmp+1],   v[\vtmp],     \denom
   _v_sub_co_u32      v[\vtmp+2],   vcc,          \numer,      v[\vtmp+1]
    v_cmp_ge_u32      s[\stmp1:\stmp1+1],         \numer,      v[\vtmp+1]
    v_cmp_ge_u32      s[\stmp2:\stmp2+1],         v[\vtmp+2],  \denom
   _v_add_co_u32      v[\vtmp+2],   vcc,          1,           v[\vtmp]
    s_and_b64         s[\stmp2:\stmp2+1], s[\stmp1:\stmp1+1],  s[\stmp2:\stmp2+1]
   _v_add_co_u32      v[\vtmp+1],   vcc, -1,      v[\vtmp]
    v_cndmask_b32     v[\vtmp+2],   v[\vtmp],     v[\vtmp+2],  s[\stmp2:\stmp2+1]
    v_cndmask_b32     v[\vtmp+2],   v[\vtmp+1],   v[\vtmp+2],  s[\stmp1:\stmp1+1]
    v_cmp_ne_i32      vcc,          0,            \denom
    v_cndmask_b32     \uquo,        -1,           v[\vtmp+2],  vcc
.endm

.altmacro
.macro ceil_2_32_div_u16 m, denom, vtmp, stmp
	v_cvt_f32_u32